{"meta":{"title":"yhwanp's devNote","subtitle":"yhwanp's devNote","description":"yhwanp's devNote","author":"yhwanp","url":"https://yhwanp.github.io","root":"/"},"pages":[{"title":"all-tags","date":"2019-07-13T06:14:10.000Z","updated":"2019-07-13T06:15:31.095Z","comments":false,"path":"all-tags/index.html","permalink":"https://yhwanp.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-07-13T06:13:49.000Z","updated":"2019-07-13T06:15:01.062Z","comments":false,"path":"all-categories/index.html","permalink":"https://yhwanp.github.io/all-categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ std::function 와 std::bind 사용법","slug":"std-function-and-std-bind","date":"2019-09-15T14:17:24.000Z","updated":"2019-09-16T12:46:01.111Z","comments":true,"path":"2019/09/15/std-function-and-std-bind/","link":"","permalink":"https://yhwanp.github.io/2019/09/15/std-function-and-std-bind/","excerpt":"","text":"std::function 란?C++11 부터 추가된 기능으로, C의 함수 포인터를 대체한다.아래와 같이 사용할 수 있다. 1234567891011void addAndPrint(int a, int b)&#123; int sum = a + b; std::cout &lt;&lt; sum &lt;&lt; \"\\n\";&#125;std::function&lt;void(int, int)&gt; func1 = addAndPrint;// 아래 두 줄은 똑같이 작동한다addAndPrint(10, 20);func1(10, 20); 위에선 전역으로 선언된 addAndPrint 함수를 std::function 으로 받고 있다.만약 class 의 멤버함수를 가르키고 싶으면, 위와는 조금 다르게 사용해야 한다. 1234567891011121314class A&#123; public: void addAndPrint(int a, int b) &#123; int sum = a + b; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; \"\\n\"; &#125;&#125;;A test;// 매개변수로 객체를 전달해야한다std::function&lt;void(A&amp;, int, int)&gt; func3 = &amp;A::addAndPrint;func3(test, 10, 20); 위처럼 멤버함수를 위해서 어떤 객체의 멤버함수를 실행할 지 알 수 있도록 객체를 전달해야 한다.그리고 13번째 줄에서 A의 addAndPrint 를 대입하기 위해 &amp;A::addAndPrint 처럼 앞에 &amp; 를 사용하고 있는데, 이 이유는 멤버함수의 경우엔 함수의 주소값으로 암시적 형변환이 되지 않아서, 명시적으로 &amp;를 사용해서 주소값을 전달해줘야 하기 때문이다. std::bind 란?std::function 과 마찬가지로 C++11 기능이며, 함수의 인자를 지정할 수 있다. 12345678void addAndPrint(int a, int b)&#123; int sum = a + b; std::cout &lt;&lt; sum &lt;&lt; \"\\n\";&#125;auto func2 = std::bind(addAndPrint, 10, std::placeholders::_1);func2(100); // addAndPrint(10, 100); 과 동일한 결과를 보장함 위 코드부턴 auto 를 사용했는데, 여기선 std::function&lt;void(int)&gt; 와 동일하다.std::bind(addAndPrint, 10, std::placeholders::_1) 의 의미는 addAndPrint(int, int) 함수의 첫 번째 파라메터는 10, 두 번째 파라메터는 func2 를 호출할 때 들어오는 첫번째 인자를 넣어준다는 의미다. 클래스 멤버함수를 클래스 내부에서 bind 시켜주는 예제를 한번 작성해보자 12345678910111213141516171819class A&#123; public: void addAndPrint(int a, int b) &#123; int sum = a + b; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; \"\\n\"; &#125; void bindFunction(std::function&lt;void(int, int)&gt;&amp; dest) &#123; dest = std::bind(&amp;A::addAndPrint, this, std::placeholders::_1, std::placeholders::_2); &#125;&#125;;A test;std::function&lt;void(int, int)&gt; func4;test.bindFunction(func4);func4(100, 200); func4는 객체 바깥에서 선언되고, A::bindFunction 에 의해서 test.addAndPrint 와 동일한 동작을 하는 함수로 bind 되었다.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"}]},{"title":"lsof - open 된 파일에 대한 정보 출력","slug":"how-to-use-lsof","date":"2019-09-15T13:00:40.000Z","updated":"2019-09-15T13:21:59.256Z","comments":true,"path":"2019/09/15/how-to-use-lsof/","link":"","permalink":"https://yhwanp.github.io/2019/09/15/how-to-use-lsof/","excerpt":"","text":"lsof 란 ?lsof 는 List Open Files 의 약자이고, 시스템에서 열린 파일 목록을 보여준다.여러가지 옵션이 많지만 주로 아래 명령어들만 사용했다. 특히 특정 프로세스가 file 을 열고 닫지 않아서 발생하는 error 및 crash 를 잡을 때 lsof - p 를 이용하면 어떤 파일을 닫지 않아 fd leak 이 발생하는지 알 수 있어서 코드 상 수정해야할 부분을 캐치하기 쉽다.또 소켓 프로그래밍을 하는 경우엔 포트 점유 목록을 출력하는 명령어가 도움이 될 수 있겠다. A. 열린 파일 목록 모두 출력 1lsof B. 특정 프로세스의 열린 파일 목록 출력 12# -p 다음에 pid 를 입력하면 된다lsof -p &lt;pid&gt; C. TCP 포트 점유 목록 출력 12# 아래는 22번 TCP 포트를 점유하는 pid 및 fd 를 출력한다lsof -i TCP:22","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/tags/linux/"}]},{"title":"C++ std::vector push_back 보단 emplace_back 을 사용하자","slug":"c-vector-emplace-back","date":"2019-09-08T16:58:39.000Z","updated":"2019-09-08T17:58:44.427Z","comments":true,"path":"2019/09/09/c-vector-emplace-back/","link":"","permalink":"https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/","excerpt":"","text":"emplace_back 을 사용하자emplace_back 은 c++11 에 추가된 std::vector 의 멤버함수다.보통 vector 에 값을 넣을 때, 아래와 같이 push_back 을 사용할 것이다. 123456std::vector&lt;std::string&gt; strList;// 이렇게 객체를 하나 선언해서 넣거나std::string A = \"test\";strList.push_back(A); // 임시 객체를 바로 전달하는 방식strList.push_back(std::string(\"test\")); 위와 같이 작성하는 것이 일반적이지만 성능 측면에서 봤을 때 emplace_back 을 사용하는 것이 훨씬 효과적이다. 123456std::vector&lt;std::string&gt; strList;strList.emplace_back(\"test\");// pair 나 생성자가 있는 다른 모든 class 도 가능std::vector&lt;std::pair&lt;int, int&gt;&gt; pairList;pairList.emplace_back(3, 5); push_back 을 사용할 때는 vector 에 값을 넣기 위해 바깥에서 임시 객체의 생성자 / 소멸자가 호출되고 vector 내부에 복사되는 과정에서 또 객체가 한번 더 생성이 되지만,emplace_back 을 사용하면, 생성자의 인자 value 들만 전달해주면 vector 내부에서 한번만 객체 생성을 한다. 거의 대부분의 경우에서 emplace_back 을 사용하는 경우의 속도가 더 빠르고 push_back 을 완벽히 대체할 수 있어서 emplace_back 사용을 권장한다고 한다. 프로젝트에서 C++11 이상을 사용한다면 emplace_back 사용을 고려해보자.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"},{"name":"vector","slug":"vector","permalink":"https://yhwanp.github.io/tags/vector/"}]},{"title":"Ubuntu SSH Welcome message 추가하기","slug":"ubuntu-ssh-welcome-message","date":"2019-09-08T10:59:05.000Z","updated":"2019-09-08T15:55:20.424Z","comments":true,"path":"2019/09/08/ubuntu-ssh-welcome-message/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/","excerpt":"","text":"client 가 SSH 에 접속할 때마다 출력되는 Welcome message 를 추가하는 방법이다.(Ubuntu 18.04 기준) 123456# /etc/update-motd.d 에 99-custom 을 생성해줌.vi /etc/update-motd.d/99-custom# 내용 예제printf \"### 내용 입력 ###\"who who 는 현재 SSH connect 되어있는 client 목록을 보여준다.출력하고 싶은 내용을 자유롭게 입력하면 된다.","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"SSH","slug":"ssh","permalink":"https://yhwanp.github.io/tags/ssh/"}]},{"title":"C++ Rvalue 와 std::move 에 대한 이해","slug":"rvalue-and-move","date":"2019-09-08T09:23:29.000Z","updated":"2019-09-08T16:58:15.649Z","comments":true,"path":"2019/09/08/rvalue-and-move/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/rvalue-and-move/","excerpt":"","text":"Rvalue 란 무엇인가?Rvalue, 우측값은 대입 시에 항상 오른쪽에만 오는 식을 말한다.예제로 이해하는 것이 쉽다. 123456789101112131415int doSomething()&#123; ... return z;&#125;int x = 10; // x 는 Lvalue, 10은 Rvalueint y = 20; // y 는 Lvalue, 20은 Rvaluex = y; // x 와 y 모두 Lvaluex = (x + y); // x 는 Lvalue, x + y 는 Rvaluex + y = 30; // 잘 못된 코드, Rvalue 인 x + y 에 대입하고 있다.x = doSomething() // doSomething() 은 Rvalue x, y 처럼 이름을 가지고 있고, 그 이름으로 접근할 수 있는 것이 Lvalue 이다.그와 반대로 (x + y) 나 상수 10, 20 등은 이름을 가지고 있지 않고 식이 끝난 후 다음 라인에서 그 값에 접근할 수 없다. Rvalue 를 함수의 매개변수로 받고 싶으면 A&amp;&amp; 로 선언한다.참고로 doSomethingWithRvalue 안에서 rhs 를 다시 사용할 때는 rhs 가 Lvalue 라는 것을 주의하자. Rvalue 로 사용하고 싶으면 다시 std::move(rhs) 와 같이 사용해주어야 한다. 123456class A;// class A의 instance를 Rvalue 로 받고 싶을 때void doSomethingWithRvalue(A&amp;&amp; rhs)&#123; &#125; std::move 를 사용해서 성능을 개선해보자std::move 는 이름 때문에 부르는 것과 동시에 어떤 이동 작업이 이뤄질 것 같지만, 실제로 Lvalue 를 Rvalue 로 casting 해줄 뿐이다. 12345678910111213141516171819class myClass&#123; public: myClass() &#123; &#125; myClass(std::string str) : data(str) &#123; &#125; std::string data;&#125;myClass A(\"aaa\");myClass B;myClass C;B = A;C = std::move(A); // Lvalue 인 A를 Rvalue 로 casting (std::string 은 실제 작은 문자열은 stack memory 에 저장하고 큰 문자열은 heap memory 에 저장하지만, 설명에선 편의를 위해 항상 heap 에 저장한다고 가정한다.) 위 코드에서 B = A 수행 시 copy 가 일어난다. (copy assignment operator)C = std::move(A) 수행 시 move 가 일어난다. (move assignment operator) B = A 를 할 때는 copy 하기 때문에 B.data 는 당연히 “aaa” 가 복사되고 A.data 도 여전히 “aaa”를 가지고 있지만C = std::move(A) 를 하면 move 하기 때문에 A.data 는 C.data 로 이동이 되어서 A.data 는 빈 문자열이 되고 C.data 는 “aaa” 를 가진다. 얻을 수 있는 이점은, 새로 메모리를 할당(malloc)하지 않아도 되고 이미 메모리에 할당된 것을 소유권만 C 에게 넘겨주기 때문에 copy 동작보다 빠르다. (move 로 할당한 이후로는 A를 사용하지 못하므로 주의) 예제를 하나 더 보자. 12345std::vector&lt;std::string&gt; stringList;&#123; std::string input = \"example\"; stringList.push_back(input);&#125; std::string 을 원소로 가지는 vector stringList 가 선언되어 있고, input 을 push_back 해준다.push_back 이 후에 input은 다시 쓰이지 않기 때문에 위 코드에서 input 은 vector에 string 을 넣기위해서만 만들어진 임시객체의 역할 밖에 되지 않는다. 이럴 때 std::move 를 사용하면 성능 향상이 될 수 있다. 12345std::vector&lt;std::string&gt; stringList;&#123; std::string input = \"example\"; stringList.push_back(std::move(input));&#125; 그리고 예제에선 std::string 이 move constructor / move assignment operator 를 지원하기 때문에 move로 기대하는 동작을 얻을 수 있는 것이고, 사용자가 정의한 class 의 경우 destructors 나 assignment operators 를 명시적으로 선언했다면 move constructor 나 move assignment operators 가 암시적으로 생성되지 않으므로 직접 작성해주거나 default 로 선언해줘야 할 것이다. 암시적으로 생성되는 move constructors 의 형태는 아래와 같다. 기본적으로 클래스 멤버변수를 std::move 해서 Rvalue 로 casting 해 초기화한다. 123456789101112class myClass&#123; public: myClass(myClass&amp;&amp; rhs) : A(std::move(rhs.A)) , B(std::move(rhs.B)) &#123; &#125; std::string A; std::string B;&#125;","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"Rvalue","slug":"rvalue","permalink":"https://yhwanp.github.io/tags/rvalue/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"}]},{"title":"Linux mount 및 reboot 후에도 자동으로 mount 시켜주기","slug":"linux-mount-and-auto-mount","date":"2019-09-08T08:41:06.000Z","updated":"2019-09-11T11:58:32.034Z","comments":true,"path":"2019/09/08/linux-mount-and-auto-mount/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/","excerpt":"","text":"mount 기본 명령어기본적으로 아래 명령어를 사용하면 된다. 12# /dev/sda1 저장매체를 /mnt/myMount 로 마운트한다.mount /dev/sda1 /mnt/myMount 이 때 마운트할 대상의 이름을 모르겠다면 ( 위 예제에서 /dev/sda1 과 같은 )fdisk -l 과 df -h 로 확인하자. 1234# 디스크 / 파티션 정보 출력sudo fdisk -l# 현재 linux system 에 mount 된 list 및 용량 출력df -h 자동으로 mount 하기위 설명대로 mount 하면 시스템을 종료하기 전까지는 mount 가 유지되지만 리붓하면 mount를 다시 해줘야 하는 불편함이 있다.reboot 이후에도 mount 상태를 유지하고 싶으면 /etc/fstab 을 수정하면 된다. 1234567# stock fstab - you probably want to override this with a machine specific one/dev/root / auto defaults 1 1proc /proc proc defaults 0 0....../dev/sda1 /mnt/myMount auto defaults 0 2 사용자마다 /etc/fstab 내용은 다를 수 있다. 기본으로 입력되어 있는 정보들은 잘 못 건드리면 부팅이 안될 수도 있으니 건드리지 말고, 마지막 줄에 mount 하고자 하는 내용을 입력하면 된다.나는 마지막 줄에 /dev/sda1 을 /mnt/myMount 로 mount 하는 line 을 추가했다.마지막에 숫자 0 2 의 의미는 각각 dump 생성 여부 / fsck 실행 순서를 나타내는데, 잘 모르겠다면 0, 2 로 셋팅하면 문제 없을 것이다.","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/tags/linux/"},{"name":"mount","slug":"mount","permalink":"https://yhwanp.github.io/tags/mount/"}]},{"title":"plink, pscp 로 SSH, SCP 사용하는 방법 (command-line, 자동화)","slug":"how-to-ssh-scp-with-command-line","date":"2019-09-01T08:24:56.000Z","updated":"2019-09-08T10:55:22.604Z","comments":true,"path":"2019/09/01/how-to-ssh-scp-with-command-line/","link":"","permalink":"https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/","excerpt":"","text":"plink, pscp 어떻게 쓰면 좋을까?회사에서 일을 할 때 SSH 나 SCP 등을 사용할 일이 많은데, 보통 아래와 같은 조합으로 사용했다.SSH : TeraTerm, Putty, PowerShell파일 전송 : FileZilla, WinSCP 위 프로그램들은 잘 사용하고 있었지만, 업무 상 반복적인 작업 들이 있었고 이를 위해 매번 같은 버튼 누르고, 같은 타이핑 하는 등.. 같은 action 을 반복하는 것이 귀찮았다.ex) SSH password / 명령어 입력, 테스트를 위해 binary 교체 및 권한 설정 등.. plink, pscp 는 이런 전송 반복적인 작업들을 피하기 위해 command-line 기반으로 어떻게 자동화를 할 수 있을 지 알아보다 발견한 툴이다.이미 Putty 를 쓰고 있다면 Putty 에 포함되어 있는 프로그램이고, 다운로드 받고 싶다면 아래 링크에서 받을 수 있다. Download link 그리고, 아래와 같이 사용하면 된다. 사용법도 간단하고 pw 를 지정할 수도 있어서 자동화할 때 좋다. 1234# 192.168.11.10 의 host 로 접속해서 pwd 명령plink.exe -ssh -pw &lt;password&gt; host@192.168.11.10 \"pwd\"# 192.168.11.10 의 ~/dest 폴더로 example.txt 를 복사pscp.exe -scp -r -pw &lt;password&gt; example.txt host@192.168.11.10:~/dest","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"SSH","slug":"ssh","permalink":"https://yhwanp.github.io/tags/ssh/"},{"name":"SCP","slug":"scp","permalink":"https://yhwanp.github.io/tags/scp/"},{"name":"Automation","slug":"automation","permalink":"https://yhwanp.github.io/tags/automation/"}]},{"title":"일론 머스크의 뉴럴링크, 뇌와 컴퓨터의 연결","slug":"elon-musk-neuralink","date":"2019-08-25T13:31:10.000Z","updated":"2019-08-25T19:54:20.044Z","comments":true,"path":"2019/08/25/elon-musk-neuralink/","link":"","permalink":"https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/","excerpt":"","text":"일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자 영상의 내용을 아주 간단하게 요약하자면, 뉴럴링크란 뇌의 대뇌피질에 작은 칩을 연결해 뇌의 뉴런들이 전달하는 전자기적 신호를 알고리즘으로 분석해서 사람의 생각, 감각, 운동능력 등에 영향을 줄 수 있는 기술이다.1차적으로 파킨슨병 같은 뇌 질환을 앓고 있는 환자들을 위해 사용될 것이고, 2020년 말에는 일반인들에게도 상용화가 될 것이라고 예상한다고 한다. 뉴럴링크가 상용화된다면, 이제 더 이상 마우스나 키보드, 모니터 와 같은 뇌와 컴퓨터간의 입력 매체 및 출력매체가 필요 없어질 수 있다. 다양한 입력 매체의 도움없이도 훨씬 빠르게, 내가 생각하는 속도로 컴퓨터를 조작하고, 출력 매체가 없이도 얻고자 하는 정보를 뇌에 주입 시킬 수도 있는 것이다. 사람들은 인공지능 컴퓨터의 도움으로 현재보다 훨씬 많은 정보를 빠르고 쉽게 습득할 수 있을 것이다. 과연 2020년 말에는 생각만으로 상호작용을 하는 고도화된 인공지능 비서를 가질 수 있을까? 아직은 전혀 실감이 나지 않지만 동물을 통한 실험도 어느정도 진행되었고 유의미한 성과를 이룬 것으로 보인다. 인간에게 적용되었을 때 안전성 / 보안성 문제만 해결된다면, 특이점을 불러올 기술이라고 생각된다.뉴럴링크는 기존의 지식, 인프라를 무너뜨릴 수도 있을 것이다. 한편으론 내가 수년 간 쌓은 지식, 경험이 이 기술이 개발됨에 따라 남들이 쉽게 따라할 수 있다고 생각하면 당장 의욕이 떨어질 수도 있겠다. 하지만 이런 시대가 올 수 있다고 아직 장담할 수 없는 단계이고, 당장 할 수 있는 것도 없다. 그저 경각심을 가지고 현실을 열심히 살면 뉴럴링크 의 시대에도 내가 할 수 있는 것이 있을 것이라고 믿고, 준비해야 한다고 생각한다.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"Neuralink","slug":"neuralink","permalink":"https://yhwanp.github.io/tags/neuralink/"},{"name":"Elon Musk","slug":"elon-musk","permalink":"https://yhwanp.github.io/tags/elon-musk/"}]},{"title":"iTerm2 3.3 release 이후 Theme 변경 및 Status Bar 사용하기","slug":"iterm2-3-3-update","date":"2019-08-21T16:36:27.000Z","updated":"2019-08-21T17:15:19.435Z","comments":true,"path":"2019/08/22/iterm2-3-3-update/","link":"","permalink":"https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/","excerpt":"","text":"새롭게 추가된 Minimal Theme하단의 Try it now 를 클릭하면 자동으로 변경됩니다. 이전 기본 테마보다 훨씬 깔끔하네요. 다시 이전 테마로 돌아가고 싶다면 Preferences - Appearance 에서 변경 할 수 있습니다. Status Bar 표시status bar 는 개인설정이 가능합니다. 배터리, CPU, RAM 사용량, 네트워크 대역폭 등 여러 정보 및 Tool 을 status bar 에 설정할 수 있네요. 개인 설정까지 완료된 모습","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"iTerm2","slug":"iterm2","permalink":"https://yhwanp.github.io/tags/iterm2/"}]},{"title":"CMake 에서 상대경로를 절대경로로 바꾸기","slug":"cmake-convert-to-absolute-path","date":"2019-08-21T15:57:53.000Z","updated":"2019-08-21T16:14:39.261Z","comments":true,"path":"2019/08/22/cmake-convert-to-absolute-path/","link":"","permalink":"https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/","excerpt":"","text":"CMake 에서 상대경로를 절대경로로 바꿔보자 왜 필요한가? CMake 에서 지원하는 여러 명령들 중에 상대 경로로 입력하면 오류가 출력되는 function 들이 있습니다.이때, 상대 경로를 절대 경로로 변환하기 위해 get_filename_component 을 사용하면 됩니다. 원형: 1get_filename_component(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE]) 아래는 ../../.. 에 해당하는 상대경로를 절대경로로 변환해서, MY_ABSOLUTE_PATH 라는 변수로 저장 시키는 예제 입니다. 1get_filename_component(MY_ABSOLUTE_PATH \"../../..\" ABSOLUTE)","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"CMake","slug":"etc/cmake","permalink":"https://yhwanp.github.io/categories/etc/cmake/"}],"tags":[{"name":"CMake","slug":"cmake","permalink":"https://yhwanp.github.io/tags/cmake/"}]},{"title":"OpenSSL을 NDK로 빌드하기","slug":"OpenSSL을-NDK로-빌드하기","date":"2019-07-28T10:02:06.000Z","updated":"2019-07-28T10:43:14.047Z","comments":true,"path":"2019/07/28/OpenSSL을-NDK로-빌드하기/","link":"","permalink":"https://yhwanp.github.io/2019/07/28/OpenSSL을-NDK로-빌드하기/","excerpt":"","text":"시작에 앞서보통 실습 용도나 로컬에서 테스트를 할 경우에는 Precompiled library 를 사용해도 되지만 상용 프로그램에 포함할 경우 암호화 알고리즘 라이센스 문제가 발생할 수 있습니다.문제가 되는 암호화 알고리즘을 제외한 Precompiled library 가 있으면 해결되지만, 특정 NDK, OpenSSL 버전을 맞춰야 하는 경우 이에 만족하는 라이브러리를 찾기가 힘들어서, 직접 빌드하는 편이 빠릅니다. 빌드 환경 및 사용 버전 NDK r18b OpenSSL 1.0.2l Ubuntu 18.04 빌드 시작하기 NDK 이용해 custom toolchain 생성 (https://developer.android.com/ndk/guides/standalone_toolchain) 1python3 $NDK/build/tools/make_standalone_toolchain.py --arch arm64 --api 26 --install-dir /opt/android-26-arm64 OpenSSL 폴더로 이동 1cd openssl-1.0.2l Clang 에서 &#39;-mandroid&#39; 를 지원하지 않으므로 Configure 파일에서 해당 부분 삭제 1sed -i -e 's/-mandroid//' Configure Confiigure 시작 1CROSS_COMPILE=/opt/android-26-arm64/bin/aarch64-linux-android- ./Configure android shared no-idea no-mdc2 no-rc5 make 시작 12make dependmake ANDROID_DEV=/opt/android-26-arm64/sysroot/usr CALC_VERSIONS=\"SHLIB_COMPAT=; SHLIB_SOVER=\" build_libs 생성된 library 가 올바르게 빌드 됐는지 확인 1readelf -h ./libcrypto.a | grep -i 'class\\|machine' | head -2","categories":[{"name":"Android","slug":"android","permalink":"https://yhwanp.github.io/categories/android/"},{"name":"NDK","slug":"android/ndk","permalink":"https://yhwanp.github.io/categories/android/ndk/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://yhwanp.github.io/tags/android/"},{"name":"NDK","slug":"ndk","permalink":"https://yhwanp.github.io/tags/ndk/"},{"name":"OpenSSL","slug":"openssl","permalink":"https://yhwanp.github.io/tags/openssl/"}]},{"title":"Hexo 블로그 폰트 사이즈 수정하기 - (Hueman 테마)","slug":"Hexo-블로그-폰트-사이즈-수정하기-Hueman-테마","date":"2019-07-28T09:17:21.000Z","updated":"2019-08-11T15:26:21.050Z","comments":true,"path":"2019/07/28/Hexo-블로그-폰트-사이즈-수정하기-Hueman-테마/","link":"","permalink":"https://yhwanp.github.io/2019/07/28/Hexo-블로그-폰트-사이즈-수정하기-Hueman-테마/","excerpt":"","text":"블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)앞서 Hexo-blog-셋팅-정리 에서 소개한 블로그들에서 소개되지 않은 부분이 있는데, 바로 게시글의 폰트 사이즈를 수정하는 방법입니다.기본 사이즈는 18px 로 설정되어 있는데, 미묘하게 큰 사이즈여서 포스트가 한 눈에 들어오지 않는 것 같아 사이즈를 수정했습니다. 수정하기 위해서 /$HEXO_HOME/themes/hueman/source/css/_variables.styl 파일을 엽니다.그리고, font-size-article 을 찾아서 원하는 사이즈로 수정합니다. 12//font-size-article = 18pxfont-size-article = 17px","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://yhwanp.github.io/tags/hexo/"},{"name":"Font","slug":"font","permalink":"https://yhwanp.github.io/tags/font/"}]},{"title":"Hexo 블로그 셋팅 총정리","slug":"Hexo-blog-setting","date":"2019-07-27T12:30:51.000Z","updated":"2019-09-03T17:36:59.158Z","comments":true,"path":"2019/07/27/Hexo-blog-setting/","link":"","permalink":"https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/","excerpt":"","text":"Hexo 블로그 만들기hexo 블로그를 만들기 위해 참고했던 사이트를 정리해보려 합니다.아래에 있는 블로그만 참조해도 꽤 괜찮은 블로그를 만들 수 있습니다.그 중에서도 Eric Han 님의 블로그의 글이 포스팅 된 지 가장 오래된 글임에도 많은 도움이 됐습니다. 튜토리얼 with Hueman 테마Eric Han’s IT Blog Powered by Hexod2fault 튜토리얼 with Tranquilpeak 테마밍피디 Markdown 문법MarkDown 사용법 총정리 190904 Update Category 나 Tag 클릭 시 404 error 해결법처음 글 썼을 때 생성한 Category 나 Tag 에서 소문자/대문자를 바꿨을 때 이를 인식하지 못 해서 발생하는 문제. 링크에 대해선 대-소문자 구분 없이 통일하는 것이 좋음.Hexo 블로그에서 카테고리(태그)가 제대로 보이지 않을 때","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://yhwanp.github.io/tags/hexo/"},{"name":"Markdown","slug":"markdown","permalink":"https://yhwanp.github.io/tags/markdown/"}]}]}