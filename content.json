{"meta":{"title":"yhwanp's devNote","subtitle":"yhwanp's devNote","description":"yhwanp's devNote","author":"yhwanp","url":"https://yhwanp.github.io"},"pages":[{"title":"all-tags","date":"2019-07-13T06:14:10.000Z","updated":"2019-07-13T06:15:31.095Z","comments":false,"path":"all-tags/index.html","permalink":"https://yhwanp.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-07-13T06:13:49.000Z","updated":"2019-07-13T06:15:01.062Z","comments":false,"path":"all-categories/index.html","permalink":"https://yhwanp.github.io/all-categories/index.html","excerpt":"","text":""}],"posts":[{"title":"툴 추천 - Everything","slug":"tool-everything","date":"2021-09-25T05:04:10.000Z","updated":"2021-10-04T17:21:51.550Z","comments":true,"path":"2021/09/25/tool-everything/","link":"","permalink":"https://yhwanp.github.io/2021/09/25/tool-everything/","excerpt":"","text":"가장 잘 쓰고 있는 툴 한가지를 추천하려고 한다.Everything 이라고 하는 프로그램인데, Windows 전용 프로그램이며 실시간 파일/폴더 검색을 지원한다. 컴퓨터에 저장한 파일이 많아지다보면 꼭 필요한 프로그램이라고 생각한다.개발할 때도 특정 설정 파일이나 소스코드를 파일 이름으로 찾는 경우가 많기 때문에 효율을 높여줄 수 있다.Windows 에 내장된 속터지는 검색은 너무 오래 걸려서 포기하기 일쑤였는데, 이 프로그램은 거의 딜레이 없이 파일을 찾아주고, 정규 표현식도 지원한다.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://yhwanp.github.io/tags/tool/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"CMake - feature_summary","slug":"cmake-featuresummary","date":"2021-09-22T14:13:43.000Z","updated":"2021-10-04T18:03:24.184Z","comments":true,"path":"2021/09/22/cmake-featuresummary/","link":"","permalink":"https://yhwanp.github.io/2021/09/22/cmake-featuresummary/","excerpt":"","text":"feature_summary 는 CMake 에 정의된 옵션이나 종속성을 확인할 때 유용한 기능이다. e.g 12345678910111213# include 필요include(FeatureSummary)find_package(Boost REQUIRED)# summary 출력 원하는 옵션은 add_feature_info 로 추가option(BUILD_TEST &quot;Build test executable&quot; OFF)add_feature_info(&quot;BUILD_TEST&quot; BUILD_TEST &quot;Build test executable&quot;)option(ENABLE_SOMETHING &quot;Enable something&quot; ON)add_feature_info(&quot;ENABLE_SOMETHING&quot; ENABLE_SOMETHING &quot;Enable something&quot;)# 출력feature_summary(WHAT ALL) Configure 하면 아래와 같이 종속 패키지 목록이나, 옵션 on/off 여부에 대한 summary 가 출력된다. 12345678910111213141516...-- The following features have been enabled: * ENABLE_SOMETHING, Enable something-- The following REQUIRED packages have been found: * boost_headers (required version == 1.76.0) * Boost-- The following features have been disabled: * BUILD_TEST, Build test executable-- Configuring done-- Generating done 프로젝트가 커질수록 dependency 나 custom option 사용이 많아져서 복잡해질 수 있는데, Configure 시 description 과 함께 출력되니 문서 대용으로 쓰일 수도 있고 한 눈에 적용 옵션들을 파악할 수도 있어서 유용해보인다.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"CMake","slug":"etc/cmake","permalink":"https://yhwanp.github.io/categories/etc/cmake/"}],"tags":[{"name":"CMake","slug":"cmake","permalink":"https://yhwanp.github.io/tags/cmake/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"CMake","slug":"etc/cmake","permalink":"https://yhwanp.github.io/categories/etc/cmake/"}]},{"title":"SSH Portforwarding","slug":"ssh-portfowarding","date":"2021-08-14T11:13:47.000Z","updated":"2021-10-04T17:01:21.807Z","comments":true,"path":"2021/08/14/ssh-portfowarding/","link":"","permalink":"https://yhwanp.github.io/2021/08/14/ssh-portfowarding/","excerpt":"","text":"SSH Portforwarding (SSH Tunnelling) 은 ssh 연결을 기반으로 대상 서버의 특정 port 를 외부에 공개할 때 사용한다.3가지 옵션이 있는데, 그 중 local portforwarding, remote portforwarding 에 대해 알아보자.두 옵션의 차이는 간단히 말해서 최종 목적지까지 터널링을 구성하는 작업의 실행 주체 에 따라 다르다. Local Portforwarding1ssh -L &#123;접근할 port&#125;:&#123;목적지 ip&#125;:&#123;목적지 port&#125; &#123;목적지 ip:port에 접근 가능한 host ip&#125; e.g. 목적지 서버(192.168.200.200)의 HTTP(:80) 가 외부에서 접근 불가하며 목적지 서버에 접근 권한이 있는 host(192.168.10.10) 와의 ssh 연결은 가능할 때 로컬의 8080 포트와 연결하고 싶다면? 아래 커맨드를 실행한다.ssh -L 8080:192.168.200.200:80 192.168.10.10 로컬에서 localhost:8080 로 접근하면 192.168.200.200:80 으로 연결된다. (마지막 파라메터는 꼭 목적지 ip 와 동일한 것이 아니고, 목적지 ip:port 에 접근이 가능한 host 의 ip 일 뿐이다.) Remote Portforwarding1ssh -R &#123;접근할 port&#125;:&#123;목적지 ip&#125;:&#123;목적지 port&#125; &#123;목적지 ip:port에 접근할 수 있도록 해줄 host ip&#125; e.g. 목적지 서버(192.168.200.200)의 HTTP(:80) 가 외부에서 접근 불가하며 목적지 서버에 접근하고자 하는 client 에게 (192.168.100.100) 8080 포트를 열어주려면?(client 또한 sshd 가 실행되고 있어야 한다) 아래 커맨드를 실행한다. ssh -R 8080:192.168.200.200:80 192.168.100.100 둘의 차이점은 Local Portforwarding 은 대상 ip:port 에 접근 권한이 없는 호스트가 목적지 서버와 연결하기 위해 사용, Remote Portforwarding 은 접근 권한을 가진 호스트가 접근하고자 하는 또 다른 호스트에게 접근할 수 있도록 할 때 사용한다는 것이다.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"SSH","slug":"ssh","permalink":"https://yhwanp.github.io/tags/ssh/"},{"name":"Network","slug":"network","permalink":"https://yhwanp.github.io/tags/network/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"DNS 를 바꾸면 인터넷 속도가 빨라지는 이유?","slug":"change-dns-to-make-internet-speed-faster","date":"2021-08-04T08:35:14.000Z","updated":"2021-08-04T11:44:48.954Z","comments":true,"path":"2021/08/04/change-dns-to-make-internet-speed-faster/","link":"","permalink":"https://yhwanp.github.io/2021/08/04/change-dns-to-make-internet-speed-faster/","excerpt":"","text":"이전에 Cloudflare 에 대한 포스트를 작성하면서 DNS 를 바꾸면 인터넷 속도가 빨라질 수 있다는 내용을 적었다.DNS 를 바꾸면 인터넷 속도가 빨라진다는 정보는 꽤 오래 전 (2010년 초반?) 부터 있었는데, 유튜브가 한국에 널리 보급되면서 유튜브 영상의 버퍼링 해결방법으로서 본격적으로 퍼진 것으로 기억한다.그리고 나도 그 시절에 SKB 인터넷을 사용했었기 때문에 구글의 public DNS 8.8.8.8 을 사용했었다. 당시에도 어떻게 DNS 를 바꾸는 것 만으로 인터넷 속도가 빨라질 수 있지? 라고 생각은 했었지만 넘어갔었는데, 최근에 cloudflare 의 1.1.1.1 을 사용해보면서 다시금 의문이 생겨서 조사해봤다. 알다시피 DNS 는 google.com 과 같은 도메인을 ip 주소로 변환해주는 역할을 한다.기본적으로 사용하는 ISP 의 DNS 를 사용하도록 설정이 되어 있다.이 기본 DNS 주소를 구글에서 제공하는 8.8.8.8 이나 클라우드플레어의 1.1.1.1 로 변경하면 인터넷 속도가 빨라진다는 것인데, 단순하게 생각했을 때 ip 주소로의 변환 역할을 하는 DNS 를 바꾼다고 해서 속도가 빨라질 수 있는지 의문을 가질 수 있다. 알아보니 DNS 서버는 도메인과 매칭되는 여러 개의 ip 중에서 가장 적절한 ip 를 골라서 알려주며 여러 개의 ip 에 균등하게 분배하는 로드 밸런싱 의 역할도 한다.Youtube, Google, Netflix … 같이 대규모 호스팅을 하는 서버는 ip 주소도 여러 개 있기 때문에,여러 개의 ip 주소를 알고 있고 적절한 ip 를 알려주는 DNS 서버로 변경할 경우 속도 향상을 기대할 수 있는 것이다.(빠른 ip 를 제공할 수 있음에도 이해 관계 때문에 제공하지 않는 경우도 있다고 한다.) 그리고 조사하면서, DNS 를 선택할 때 tracert 와 같은 tool 로 패킷의 지연 측정을 해서 가장 지연이 적은 DNS 를 선택하라는 내용의 글도 많았는데, 이 경우 단순하게 도메인과 ip 변환까지 걸리는 지연을 측정하는 것이기 때문에 해외 서비스의 속도를 개선하는 목적으로서는 적절한 선택기준이 될 수 없을 것이다. (보통은 사용하고 있는 ISP 에서 기본 제공하는 DNS 가 가장 지연이 적다. 하지만 DNS 서버와의 통신은 전체 통신에서 극히 일부분이고 최초 access 이후에는 그마저 cache 될 수 있다.) 따라서 DNS 변경을 통한 속도 향상은 해외 서비스를 이용할 때 사용할 수 있는, 기술적으로 유효한 방법이라고 생각된다. (LOL 도 DNS 서버 변경으로 속도 개선될 수 있는 듯)특히 SKB 인터넷을 사용할 경우 해외 서비스 속도가 느린 것이 체감이 되므로 1.1.1.1 이나 KT DNS 를 사용하는 것을 개인적으로 추천한다.다만 DNS 변경으로 국내 서비스는 더 느려질 수 있는데, 내 사용 패턴에서는 국내 서비스가 느려지는 경험은 없었다. 각자의 인터넷 사용 패턴에 따라 적절한 선택을 하자.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"DNS","slug":"dns","permalink":"https://yhwanp.github.io/tags/dns/"},{"name":"Network","slug":"network","permalink":"https://yhwanp.github.io/tags/network/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"Cloudflare 에 대해","slug":"about-cloudflare","date":"2021-07-18T14:44:53.000Z","updated":"2021-08-04T10:40:04.475Z","comments":true,"path":"2021/07/18/about-cloudflare/","link":"","permalink":"https://yhwanp.github.io/2021/07/18/about-cloudflare/","excerpt":"","text":"Cloudflare 는 DNS 와 CDN 서비스를 제공하는 미국 기업이자 서비스이다.무료로도 꽤 많은 기능을 제공해주기 때문에 개인이나 소규모 서비스를 제공하는 사람들도 부담없이 사용할 수 있고 cloudflare 를 사용함으로서 꽤 많은 effort 를 절약할 수 있어 보인다.cloudflare 의 기능을 크게 3가지 측면에서 정리해봤다. 보안 측면 서버의 ip 가 외부에 직접 노출되지 않는다. cloudflare 의 서버를 거쳐서 통신하기 때문. cloudflare 의 서버에서 DDoS 방어를 제공한다. 복잡한 https 셋팅 없이 웹서버를 배포할 수 있다. SQL injection, XSS 등에 대한 방어 제공 퍼포먼스 측면 전 세계에 cloudflare 캐시 서버가 있어 접속 속도가 빨라질 수 있다. ** 하지만 사실상 한국에서는 여러가지 문제로 더 느려질 수 있는 것 같다.** 인터넷 속도가 빠른 한국에서는 캐시서버보다 직접 서버에 접근하는게 더 빠르고, 한국에 위치한 Cloudflare 캐시서버가 있지만 한국의 캐시서버로 연결되지 않고 해외의 캐시서버로 연결되는 경우 속도는 더 느려진다. 편의 측면 cloudflare 서버에서 실제 서버로 redirect 될 때 cloudflare 에서 제공하는 추가 정보가 header 로 제공된다 ( 접속 지역 등.. ) 복잡한 https 셋팅 없이 웹서버를 배포할 수 있다. cloudflare 와 실제 서버간 연결은 http 로 구성 가능. 특정 ip 주소나 국가의 트래픽을 black list / white list 로 관리 이외에도 많은 기능을 제공하지만 사용해보지 않은 입장이라 당장 와닿는 굵직한 기능들만 서술했다.언젠가 웹서비스를 만들 기회가 있으면 써보고 싶은 서비스이다. cloudflare 서버에 보안상 문제가 발생하면 우리 데이터도 위험해질 수 있다는 점은 유념해야하지만 그렇다할 보안 인력이 없는 개인이나 중소 서비스를 운영하는 입장에서는 cloudflare 를 사용하는 편이 더 안전하지 않을까 생각한다. 그리고 이외에도 cloudflare 는 Public DNS service, VPN 을 제공 중이다.이 서비스는 서버를 운영하지 않더라도, 일반인들도 관심만 있다면 사용해볼 수 있는 서비스이다. cloudflare 의 public DNS server 는 1.1.1.1 로, 이를 사용할 시 DNS 쿼리가 감청되는 것을 막을 수 있고 경우에 따라 해외 서비스를 이용할 때 속도 향상을 기대할 수 있다. (특히 SKB 인터넷을 사용한다면 해외 서비스.. 유튜브, 넷플릭스, 앱스토어 등의 속도가 느릴 때가 있다.) 구글의 dns 인 8.8.8.8 보다 1.1.1.1 이 더 빠르다고 한다.DNS 변경을 통한 속도 향상에 대해 관심이 있다면 아래 링크를 참고 바란다. DNS 를 바꾸면 인터넷 속도가 빨라지는 이유? VPN 서비스도 WARP 라는 이름으로 제공하는데 개인적으로 사용할 일은 별로 없을 것 같고, 궁금하다면 1.1.1.1 페이지를 참고하자.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"DNS","slug":"dns","permalink":"https://yhwanp.github.io/tags/dns/"},{"name":"Network","slug":"network","permalink":"https://yhwanp.github.io/tags/network/"},{"name":"VPN","slug":"vpn","permalink":"https://yhwanp.github.io/tags/vpn/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"Codility 4-4 MaxCounters","slug":"codility-4-4-maxcounters","date":"2019-12-30T14:57:32.000Z","updated":"2021-08-04T11:03:13.447Z","comments":true,"path":"2019/12/30/codility-4-4-maxcounters/","link":"","permalink":"https://yhwanp.github.io/2019/12/30/codility-4-4-maxcounters/","excerpt":"","text":"Codility 4-4 MaxCounters For example, given integer N = 5 and array A such that: 1234567A[0] = 3 A[1] = 4 A[2] = 4 A[3] = 6 A[4] = 1 A[5] = 4 A[6] = 4 the values of the counters after each consecutive operation will be: 1234567(0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2, 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2) The goal is to calculate the value of every counter after all operations. 시간복잡도 때문에 77% 에서 100%최초에 짰을때는 문제그대로 시뮬레이션 해서 1~N 까지의 값일땐 해당 인덱스의 값을 ++ 해주고N+1 일때 모든 인덱스의 값을 max값으로 채워줬음.이때 모든 인덱스의 값을 채워주는 과정에서 시간이 N만큼 들어서 시간 복잡도가 A.length * N 되어버림. 그래서 min 값을 따로 두고해당 인덱스의 값이 min 보다 크거나 같을경우 ++ ,min 보다 작을경우 min+1 으로 대입해줌이렇게 해주면 N+1 을 만날때마다 모든 인덱스의 값을 채우는 비효율을 개선할 수 있음. 1234567891011121314151617181920212223242526272829public static int[] solution(int N, int[] A) &#123; // write your code in Java SE int[] ans = new int[N]; int max = 0; int min = 0; for(int i = 0; i &lt; A.length; i++) &#123; if(A[i] == N+1) &#123; min = max; &#125; else &#123; if(min &lt;= ans[A[i]-1]) ans[A[i]-1]++; else &#123; ans[A[i]-1] = min+1; &#125; if(ans[A[i]-1] &gt; max) max = ans[A[i]-1]; &#125; &#125; for(int i = 0; i &lt; N; i++) &#123; if(ans[i] &lt; min) ans[i] = min; &#125; return ans;&#125;","categories":[{"name":"Algorithm","slug":"algorithm","permalink":"https://yhwanp.github.io/categories/algorithm/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://yhwanp.github.io/tags/algorithm/"},{"name":"codility","slug":"codility","permalink":"https://yhwanp.github.io/tags/codility/"}],"keywords":[{"name":"Algorithm","slug":"algorithm","permalink":"https://yhwanp.github.io/categories/algorithm/"}]},{"title":"C++ const 와 constexpr","slug":"const-and-constexpr","date":"2019-12-25T14:34:10.000Z","updated":"2019-12-29T17:55:24.283Z","comments":true,"path":"2019/12/25/const-and-constexpr/","link":"","permalink":"https://yhwanp.github.io/2019/12/25/const-and-constexpr/","excerpt":"","text":"constconst 를 선언함으로서 값을 고정할 수 있다.실수를 줄일 수 있기 때문에 const 를 쓸 수 있는 상황에서는 무조건 사용하는 게 좋다.아래와 같은 쓰임새가 있다. 12345678910111213class Example&#123; public: // 파라메터를 const 로 해서, 함수 내부에서 inpString을 변경하지 못하게 함 void setString(const std::string&amp; inpString); // 리턴을 const 로 해서, 외부에서 멤버 str 을 변경하지 못하게 함 const std::string&amp; getStringRef(); // print 만 수행하는 함수이므로 함수 내부에서 멤버 변수를 변경하지 못하게 함 void printString() const; private: std::string str;&#125; constexprC++11 에 도입된 것으로, const 와 비슷하지만 constexpr 은 Compile time에 값이 결정되기를 원할 때 사용한다. 또 compile time 에 값을 결정하는 방법으로는 템플릿 메타 프로그래밍을 이용하는 방법이 있는데 가독성이나 사용성면에서나 constexpr 로 사용하는 것이 좋겠다. 그런데 함수를 constexpr 로 선언하더라도 compile time 에 결정될 수 있고 runtime 에 결정될 수도 있다. 이는 컴파일러의 어떤 평가 기준에 따라 결정 되는데 항상 compile time 에 결정되기 원하는 값이라면 리턴을 받는 변수를 constexpr 로 선언하면 된다.연산량이 너무 많다면 compile time 에 결정하지 못할 수도 있다. (Compile error 발생)아래 코드를 보면서 이해해보자. 1234567891011constexpr int Factorial(int n)&#123; return n &lt;= 1 ? 1 : n * Factorial(n - 1);&#125;// &quot;constexpr int retVal&quot; 로 받기 때문에 compile time 에 결정한다.constexpr int retVal = Factorial(3);// 변수를 사용할 시 runtime 에 결정int a = getInp;int retVal = Factorial(a);","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"const","slug":"const","permalink":"https://yhwanp.github.io/tags/const/"},{"name":"constexpr","slug":"constexpr","permalink":"https://yhwanp.github.io/tags/constexpr/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"C++ Web IDE 추천","slug":"c-web-ide","date":"2019-12-19T15:57:37.000Z","updated":"2019-12-29T17:34:49.144Z","comments":true,"path":"2019/12/20/c-web-ide/","link":"","permalink":"https://yhwanp.github.io/2019/12/20/c-web-ide/","excerpt":"","text":"코딩을 하다보면 내가 짜는 코드가 실제로 어떻게 동작하는지 헷갈리거나 컴파일러 별로 동작이 다른 부분을 직접 확인해보고 싶을 때가 있는데, 그럴 때 Web IDE 를 사용하는 편이다.속도도 빠른 편이고, 컴파일러 선택 옵션이나 기능들도 충분하다고 생각된다.작성한 C++ code 를 실시간으로 assembly code 로 보여주는 기능도 있어서, assembly 를 배우는 목적으로 사용해도 괜찮을 것 같다. https://gcc.godbolt.org","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"web ide","slug":"web-ide","permalink":"https://yhwanp.github.io/tags/web-ide/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"Ubuntu 18.04 DNS 설정하기 (초기화 문제 해결)","slug":"ubuntu-dns-setting","date":"2019-12-15T15:54:23.000Z","updated":"2019-12-29T18:02:10.730Z","comments":true,"path":"2019/12/16/ubuntu-dns-setting/","link":"","permalink":"https://yhwanp.github.io/2019/12/16/ubuntu-dns-setting/","excerpt":"","text":"Linux OS의 DNS 셋팅하기 위해서 일반적으로 /etc/resolv.conf 를 수정하는데,Ubuntu 18.04 환경에서 수정 후 도메인 서버가 변경은 되는데, 재부팅 후 다시 초기화 되는 현상이 있어 불편하게 사용하다가 해결한 방법을 정리한다. 구글링 해보면 다양한 해결 방법이 있는데, 이 방법이 가장 올바른 수정 방법으로 보인다./etc/resolv.conf 를 열어보면 주석으로 generated 된 파일이며, 수동으로 변경하지 말 것을 권하고 있다.Ubuntu 18.04 에서는 systemd-resolved 를 사용하기 때문에 아래 파일을 수정하면 된다. 1vi /etc/systemd/resolved.conf 옵션들에 대한 자세한 설명은 wiki page 를 참고한다.","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"Ubuntu","slug":"ubuntu","permalink":"https://yhwanp.github.io/tags/ubuntu/"},{"name":"DNS","slug":"dns","permalink":"https://yhwanp.github.io/tags/dns/"}],"keywords":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}]},{"title":"C/C++ free/delete 없이 프로그램을 종료한다면?","slug":"c-delete-free-when-process-exit","date":"2019-12-14T11:04:24.000Z","updated":"2019-12-29T15:18:04.322Z","comments":true,"path":"2019/12/14/c-delete-free-when-process-exit/","link":"","permalink":"https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/","excerpt":"","text":"delete/free 는 C++/C 개발할 때 꼭 빼먹어서는 안되는 중요한 키워드이다.관련해서 학부 시절에 실습 과제를 제출하는 시스템이 있었다.어려운 실습 과제에 허덕이던 동기들끼리 농담으로 “malloc 으로 동적할당을 크게 잡아버리고 free 안해서 서버 다운시켜 버리자.” 라는 얘기를 한 적이 있다. 그 당시에는 잘 몰라서 위와 같이 코딩해서 제출하면 정말 서버가 다운되는 줄 알았지만실제로는 그럴 일은 드물다.왜냐면, 최근의 OS 들은 process 종료 시 사용중인 memory 를 자동으로 반환한다.따라서 일반적인 경우 program lifecycle 이 끝난 뒤에는 memory 를 자동으로 반환 시켜줄 것이다. (그리고.. 과제 제출 시스템은 cpu / memory 사용량을 제어하는 cgroup 과 같은 시스템이 있지 않았을까..?) 그런데 이와같이 메모리 해제를 OS 에 의지하는 것은 나쁜 습관이다.알고리즘 과제 혹은 간단한 컨버팅 프로그램 같이 몇초 내에 끝내는 간단한 로직이라면 문제가 발생하진 않겠지만 이보다 큰 스케일의 프로그램에 우리가 메모리 해제 없이 코딩한 프로그램을 이식시켜야 하는 상황이 온다면, 그리고 그 프로그램이 오랫동안 길게 동작하는 프로그램이라면 프로그램 실행중에 memory leak 이 발생할 것이고 점점 시스템 자원을 갉아먹어서 프로그램을 재시작 해야 하는 상황까지 오게 될 것이다.어떤 프로그램을 사용할 때 처음 실행했을 때는 빠릿빠릿한데, 점점 사용하다보면 느려졌던 경우가 다들 한번씩은 있었을 것이다. 보통 최적화 문제가 있는 게임에서 이런 현상을 경험하는 유저들이 많다. 이런 경우가 자원 관리가 되지 않아서 발생하는 문제일 것이다. 그리고 또 한 가지는 메모리 해제를 명시적으로 해주면 클래스의 소멸 순서를 보장할 수 있기 때문에 이는 개발자의 의도대로 프로그램이 안정적으로 종료되는 것에 도움이 된다. 요약 정리 Process 종료 시 Operating System 은 Process 가 사용중인 메모리를 자동으로 모두 반환 시킨다. 그렇지만 위와 같이 OS에 메모리 해제를 맡기는 습관은 잘 못된 습관이다.왜냐하면 우리는 앞으로 충분히 긴 시간 동안 동작하는 프로그램도 짜야하며, 이식성 좋고 안정적인 프로그램을 짜야한다.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"Process","slug":"process","permalink":"https://yhwanp.github.io/tags/process/"},{"name":"delete","slug":"delete","permalink":"https://yhwanp.github.io/tags/delete/"},{"name":"free","slug":"free","permalink":"https://yhwanp.github.io/tags/free/"},{"name":"memory","slug":"memory","permalink":"https://yhwanp.github.io/tags/memory/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"C++ try-catch 예외처리와 성능","slug":"c-try-catch-exeption-with-performance","date":"2019-12-09T17:36:58.000Z","updated":"2019-12-29T14:47:18.251Z","comments":true,"path":"2019/12/10/c-try-catch-exeption-with-performance/","link":"","permalink":"https://yhwanp.github.io/2019/12/10/c-try-catch-exeption-with-performance/","excerpt":"","text":"C++ 에서 예외처리는 overhead 가 있다는 것은 익히 알고 있을 것이다.그럼에도 try-catch 구문이 꼭 필요한 경우가 있는데, overhead 가 있다는 것이 예상만 되지 exception 발생 유무에 따른 성능 차이에 대해서 궁금해져서 성능 상 얼마나 차이가 있을지 찾아보았다. 결론은 ‘try-catch 를 사용하더라도, exception 이 실제로 발생하지 않거나, 거의 발생하지 않는다면 성능에 영향은 거의 없다’ 이다. 위와 같은 경우에는 사용 시 괜한 걱정하지 않아도 된다. 아래 정말 자세하게 테스트한 실험글이 있어서, 좀 더 자세한 데이터를 원하면 아래를 참고.C++ 이야기 서른두번째: 예외가 성능에 미치는 영향","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"try-catch","slug":"try-catch","permalink":"https://yhwanp.github.io/tags/try-catch/"},{"name":"예외처리","slug":"예외처리","permalink":"https://yhwanp.github.io/tags/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/"},{"name":"exception","slug":"exception","permalink":"https://yhwanp.github.io/tags/exception/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"C++ Korea 6th Semina 후기 (2019-09-29)","slug":"cpp-korea-6th-semina","date":"2019-10-06T12:18:39.000Z","updated":"2019-12-08T18:27:29.080Z","comments":true,"path":"2019/10/06/cpp-korea-6th-semina/","link":"","permalink":"https://yhwanp.github.io/2019/10/06/cpp-korea-6th-semina/","excerpt":"","text":"2019-09-29 일요일에 C++ Korea 에서 주최하는 Semina 가 있었다.보통 이런 세미나들이 다 그렇듯이 서울에서 열려서, 부산에 사는 입장에선 차비, 숙박비 등 합치면 돈도 꽤 들고, 이동 시간도 많이 소요돼서 조금 고민되긴 했었으나 요즘 C++ 을 주제로 하는 세미나는 거의 없고, session 내용을 보니 들어보고 싶은 내용이 많아서 참석하게 됐다. 세미나 장소는 광화문에 있는 마이크로소프트 코리아였다. 내용은 모두 만족스럽고 재밌었다. 지금은 모던 C++ 쪽 경험이 별로 없어서 모던 쪽은 잘 모르는데 개인적으로 사용해보고 싶어지고 흥미가 생기는 내용이었다. 인상깊었던 내용들은 다시 블로그에 정리해볼 생각이다.별 일 없다면 다음 C++ Korea 세미나도 참석할 것 같다.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"Semina","slug":"semina","permalink":"https://yhwanp.github.io/tags/semina/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"C++ std::function 와 std::bind 사용법","slug":"std-function-and-std-bind","date":"2019-09-15T14:17:24.000Z","updated":"2019-09-16T12:46:01.111Z","comments":true,"path":"2019/09/15/std-function-and-std-bind/","link":"","permalink":"https://yhwanp.github.io/2019/09/15/std-function-and-std-bind/","excerpt":"","text":"std::function 란?C++11 부터 추가된 기능으로, C의 함수 포인터를 대체한다.아래와 같이 사용할 수 있다. 1234567891011void addAndPrint(int a, int b)&#123; int sum = a + b; std::cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125;std::function&lt;void(int, int)&gt; func1 = addAndPrint;// 아래 두 줄은 똑같이 작동한다addAndPrint(10, 20);func1(10, 20); 위에선 전역으로 선언된 addAndPrint 함수를 std::function 으로 받고 있다.만약 class 의 멤버함수를 가르키고 싶으면, 위와는 조금 다르게 사용해야 한다. 1234567891011121314class A&#123; public: void addAndPrint(int a, int b) &#123; int sum = a + b; std::cout &lt;&lt; &quot;sum: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; &#125;&#125;;A test;// 매개변수로 객체를 전달해야한다std::function&lt;void(A&amp;, int, int)&gt; func3 = &amp;A::addAndPrint;func3(test, 10, 20); 위처럼 멤버함수를 위해서 어떤 객체의 멤버함수를 실행할 지 알 수 있도록 객체를 전달해야 한다.그리고 13번째 줄에서 A의 addAndPrint 를 대입하기 위해 &amp;A::addAndPrint 처럼 앞에 &amp; 를 사용하고 있는데, 이 이유는 멤버함수의 경우엔 함수의 주소값으로 암시적 형변환이 되지 않아서, 명시적으로 &amp;를 사용해서 주소값을 전달해줘야 하기 때문이다. std::bind 란?std::function 과 마찬가지로 C++11 기능이며, 함수의 인자를 지정할 수 있다. 12345678void addAndPrint(int a, int b)&#123; int sum = a + b; std::cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125;auto func2 = std::bind(addAndPrint, 10, std::placeholders::_1);func2(100); // addAndPrint(10, 100); 과 동일한 결과를 보장함 위 코드부턴 auto 를 사용했는데, 여기선 std::function&lt;void(int)&gt; 와 동일하다.std::bind(addAndPrint, 10, std::placeholders::_1) 의 의미는 addAndPrint(int, int) 함수의 첫 번째 파라메터는 10, 두 번째 파라메터는 func2 를 호출할 때 들어오는 첫번째 인자를 넣어준다는 의미다. 클래스 멤버함수를 클래스 내부에서 bind 시켜주는 예제를 한번 작성해보자 12345678910111213141516171819class A&#123; public: void addAndPrint(int a, int b) &#123; int sum = a + b; std::cout &lt;&lt; &quot;sum: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; &#125; void bindFunction(std::function&lt;void(int, int)&gt;&amp; dest) &#123; dest = std::bind(&amp;A::addAndPrint, this, std::placeholders::_1, std::placeholders::_2); &#125;&#125;;A test;std::function&lt;void(int, int)&gt; func4;test.bindFunction(func4);func4(100, 200); func4는 객체 바깥에서 선언되고, A::bindFunction 에 의해서 test.addAndPrint 와 동일한 동작을 하는 함수로 bind 되었다.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"lsof - open 된 파일에 대한 정보 출력","slug":"how-to-use-lsof","date":"2019-09-15T13:00:40.000Z","updated":"2019-09-15T13:21:59.256Z","comments":true,"path":"2019/09/15/how-to-use-lsof/","link":"","permalink":"https://yhwanp.github.io/2019/09/15/how-to-use-lsof/","excerpt":"","text":"lsof 란 ?lsof 는 List Open Files 의 약자이고, 시스템에서 열린 파일 목록을 보여준다.여러가지 옵션이 많지만 주로 아래 명령어들만 사용했다. 특히 특정 프로세스가 file 을 열고 닫지 않아서 발생하는 error 및 crash 를 잡을 때 lsof - p 를 이용하면 어떤 파일을 닫지 않아 fd leak 이 발생하는지 알 수 있어서 코드 상 수정해야할 부분을 캐치하기 쉽다.또 소켓 프로그래밍을 하는 경우엔 포트 점유 목록을 출력하는 명령어가 도움이 될 수 있겠다. A. 열린 파일 목록 모두 출력 1lsof B. 특정 프로세스의 열린 파일 목록 출력 12# -p 다음에 pid 를 입력하면 된다lsof -p &lt;pid&gt; C. TCP 포트 점유 목록 출력 12# 아래는 22번 TCP 포트를 점유하는 pid 및 fd 를 출력한다lsof -i TCP:22","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}]},{"title":"C++ std::vector push_back 보단 emplace_back 을 사용하자","slug":"c-vector-emplace-back","date":"2019-09-08T16:58:39.000Z","updated":"2019-09-08T17:58:44.427Z","comments":true,"path":"2019/09/09/c-vector-emplace-back/","link":"","permalink":"https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/","excerpt":"","text":"emplace_back 을 사용하자emplace_back 은 c++11 에 추가된 std::vector 의 멤버함수다.보통 vector 에 값을 넣을 때, 아래와 같이 push_back 을 사용할 것이다. 123456std::vector&lt;std::string&gt; strList;// 이렇게 객체를 하나 선언해서 넣거나std::string A = &quot;test&quot;;strList.push_back(A); // 임시 객체를 바로 전달하는 방식strList.push_back(std::string(&quot;test&quot;)); 위와 같이 작성하는 것이 일반적이지만 성능 측면에서 봤을 때 emplace_back 을 사용하는 것이 훨씬 효과적이다. 123456std::vector&lt;std::string&gt; strList;strList.emplace_back(&quot;test&quot;);// pair 나 생성자가 있는 다른 모든 class 도 가능std::vector&lt;std::pair&lt;int, int&gt;&gt; pairList;pairList.emplace_back(3, 5); push_back 을 사용할 때는 vector 에 값을 넣기 위해 바깥에서 임시 객체의 생성자 / 소멸자가 호출되고 vector 내부에 복사되는 과정에서 또 객체가 한번 더 생성이 되지만,emplace_back 을 사용하면, 생성자의 인자 value 들만 전달해주면 vector 내부에서 한번만 객체 생성을 한다. 거의 대부분의 경우에서 emplace_back 을 사용하는 경우의 속도가 더 빠르고 push_back 을 완벽히 대체할 수 있어서 emplace_back 사용을 권장한다고 한다. 프로젝트에서 C++11 이상을 사용한다면 emplace_back 사용을 고려해보자.","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"},{"name":"vector","slug":"vector","permalink":"https://yhwanp.github.io/tags/vector/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"Ubuntu SSH Welcome message 추가하기","slug":"ubuntu-ssh-welcome-message","date":"2019-09-08T10:59:05.000Z","updated":"2019-09-08T15:55:20.424Z","comments":true,"path":"2019/09/08/ubuntu-ssh-welcome-message/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/","excerpt":"","text":"client 가 SSH 에 접속할 때마다 출력되는 Welcome message 를 추가하는 방법이다.(Ubuntu 18.04 기준) 123456# /etc/update-motd.d 에 99-custom 을 생성해줌.vi /etc/update-motd.d/99-custom# 내용 예제printf &quot;### 내용 입력 ###&quot;who who 는 현재 SSH connect 되어있는 client 목록을 보여준다.출력하고 싶은 내용을 자유롭게 입력하면 된다.","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"SSH","slug":"ssh","permalink":"https://yhwanp.github.io/tags/ssh/"}],"keywords":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}]},{"title":"C++ Rvalue 와 std::move 에 대한 이해","slug":"rvalue-and-move","date":"2019-09-08T09:23:29.000Z","updated":"2019-09-08T16:58:15.649Z","comments":true,"path":"2019/09/08/rvalue-and-move/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/rvalue-and-move/","excerpt":"","text":"Rvalue 란 무엇인가?Rvalue, 우측값은 대입 시에 항상 오른쪽에만 오는 식을 말한다.예제로 이해하는 것이 쉽다. 123456789101112131415int doSomething()&#123; ... return z;&#125;int x = 10; // x 는 Lvalue, 10은 Rvalueint y = 20; // y 는 Lvalue, 20은 Rvaluex = y; // x 와 y 모두 Lvaluex = (x + y); // x 는 Lvalue, x + y 는 Rvaluex + y = 30; // 잘 못된 코드, Rvalue 인 x + y 에 대입하고 있다.x = doSomething() // doSomething() 은 Rvalue x, y 처럼 이름을 가지고 있고, 그 이름으로 접근할 수 있는 것이 Lvalue 이다.그와 반대로 (x + y) 나 상수 10, 20 등은 이름을 가지고 있지 않고 식이 끝난 후 다음 라인에서 그 값에 접근할 수 없다. Rvalue 를 함수의 매개변수로 받고 싶으면 A&amp;&amp; 로 선언한다.참고로 doSomethingWithRvalue 안에서 rhs 를 다시 사용할 때는 rhs 가 Lvalue 라는 것을 주의하자. Rvalue 로 사용하고 싶으면 다시 std::move(rhs) 와 같이 사용해주어야 한다. 123456class A;// class A의 instance를 Rvalue 로 받고 싶을 때void doSomethingWithRvalue(A&amp;&amp; rhs)&#123; &#125; std::move 를 사용해서 성능을 개선해보자std::move 는 이름 때문에 부르는 것과 동시에 어떤 이동 작업이 이뤄질 것 같지만, 실제로 Lvalue 를 Rvalue 로 casting 해줄 뿐이다. 12345678910111213141516171819class myClass&#123; public: myClass() &#123; &#125; myClass(std::string str) : data(str) &#123; &#125; std::string data;&#125;myClass A(&quot;aaa&quot;);myClass B;myClass C;B = A;C = std::move(A); // Lvalue 인 A를 Rvalue 로 casting (std::string 은 실제 작은 문자열은 stack memory 에 저장하고 큰 문자열은 heap memory 에 저장하지만, 설명에선 편의를 위해 항상 heap 에 저장한다고 가정한다.) 위 코드에서 B = A 수행 시 copy 가 일어난다. (copy assignment operator)C = std::move(A) 수행 시 move 가 일어난다. (move assignment operator) B = A 를 할 때는 copy 하기 때문에 B.data 는 당연히 “aaa” 가 복사되고 A.data 도 여전히 “aaa”를 가지고 있지만C = std::move(A) 를 하면 move 하기 때문에 A.data 는 C.data 로 이동이 되어서 A.data 는 빈 문자열이 되고 C.data 는 “aaa” 를 가진다. 얻을 수 있는 이점은, 새로 메모리를 할당(malloc)하지 않아도 되고 이미 메모리에 할당된 것을 소유권만 C 에게 넘겨주기 때문에 copy 동작보다 빠르다. (move 로 할당한 이후로는 A를 사용하지 못하므로 주의) 예제를 하나 더 보자. 12345std::vector&lt;std::string&gt; stringList;&#123; std::string input = &quot;example&quot;; stringList.push_back(input);&#125; std::string 을 원소로 가지는 vector stringList 가 선언되어 있고, input 을 push_back 해준다.push_back 이 후에 input은 다시 쓰이지 않기 때문에 위 코드에서 input 은 vector에 string 을 넣기위해서만 만들어진 임시객체의 역할 밖에 되지 않는다. 이럴 때 std::move 를 사용하면 성능 향상이 될 수 있다. 12345std::vector&lt;std::string&gt; stringList;&#123; std::string input = &quot;example&quot;; stringList.push_back(std::move(input));&#125; 그리고 예제에선 std::string 이 move constructor / move assignment operator 를 지원하기 때문에 move로 기대하는 동작을 얻을 수 있는 것이고, 사용자가 정의한 class 의 경우 destructors 나 assignment operators 를 명시적으로 선언했다면 move constructor 나 move assignment operators 가 암시적으로 생성되지 않으므로 직접 작성해주거나 default 로 선언해줘야 할 것이다. 암시적으로 생성되는 move constructors 의 형태는 아래와 같다. 기본적으로 클래스 멤버변수를 std::move 해서 Rvalue 로 casting 해 초기화한다. 123456789101112class myClass&#123; public: myClass(myClass&amp;&amp; rhs) : A(std::move(rhs.A)) , B(std::move(rhs.B)) &#123; &#125; std::string A; std::string B;&#125;","categories":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/tags/c/"},{"name":"Rvalue","slug":"rvalue","permalink":"https://yhwanp.github.io/tags/rvalue/"},{"name":"std","slug":"std","permalink":"https://yhwanp.github.io/tags/std/"}],"keywords":[{"name":"C++","slug":"c","permalink":"https://yhwanp.github.io/categories/c/"}]},{"title":"Linux mount 및 reboot 후에도 자동으로 mount 시켜주기","slug":"linux-mount-and-auto-mount","date":"2019-09-08T08:41:06.000Z","updated":"2019-09-11T11:58:32.034Z","comments":true,"path":"2019/09/08/linux-mount-and-auto-mount/","link":"","permalink":"https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/","excerpt":"","text":"mount 기본 명령어기본적으로 아래 명령어를 사용하면 된다. 12# /dev/sda1 저장매체를 /mnt/myMount 로 마운트한다.mount /dev/sda1 /mnt/myMount 이 때 마운트할 대상의 이름을 모르겠다면 ( 위 예제에서 /dev/sda1 과 같은 )fdisk -l 과 df -h 로 확인하자. 1234# 디스크 / 파티션 정보 출력sudo fdisk -l# 현재 linux system 에 mount 된 list 및 용량 출력df -h 자동으로 mount 하기위 설명대로 mount 하면 시스템을 종료하기 전까지는 mount 가 유지되지만 리붓하면 mount를 다시 해줘야 하는 불편함이 있다.reboot 이후에도 mount 상태를 유지하고 싶으면 /etc/fstab 을 수정하면 된다. 1234567# stock fstab - you probably want to override this with a machine specific one/dev/root / auto defaults 1 1proc /proc proc defaults 0 0....../dev/sda1 /mnt/myMount auto defaults 0 2 사용자마다 /etc/fstab 내용은 다를 수 있다. 기본으로 입력되어 있는 정보들은 잘 못 건드리면 부팅이 안될 수도 있으니 건드리지 말고, 마지막 줄에 mount 하고자 하는 내용을 입력하면 된다.나는 마지막 줄에 /dev/sda1 을 /mnt/myMount 로 mount 하는 line 을 추가했다.마지막에 숫자 0 2 의 의미는 각각 dump 생성 여부 / fsck 실행 순서를 나타내는데, 잘 모르겠다면 0, 2 로 셋팅하면 문제 없을 것이다.","categories":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/tags/linux/"},{"name":"mount","slug":"mount","permalink":"https://yhwanp.github.io/tags/mount/"}],"keywords":[{"name":"Linux","slug":"linux","permalink":"https://yhwanp.github.io/categories/linux/"}]},{"title":"plink, pscp 로 SSH, SCP 사용하는 방법 (command-line, 자동화)","slug":"how-to-ssh-scp-with-command-line","date":"2019-09-01T08:24:56.000Z","updated":"2019-09-08T10:55:22.604Z","comments":true,"path":"2019/09/01/how-to-ssh-scp-with-command-line/","link":"","permalink":"https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/","excerpt":"","text":"plink, pscp 어떻게 쓰면 좋을까?회사에서 일을 할 때 SSH 나 SCP 등을 사용할 일이 많은데, 보통 아래와 같은 조합으로 사용했다.SSH : TeraTerm, Putty, PowerShell파일 전송 : FileZilla, WinSCP 위 프로그램들은 잘 사용하고 있었지만, 업무 상 반복적인 작업 들이 있었고 이를 위해 매번 같은 버튼 누르고, 같은 타이핑 하는 등.. 같은 action 을 반복하는 것이 귀찮았다.ex) SSH password / 명령어 입력, 테스트를 위해 binary 교체 및 권한 설정 등.. plink, pscp 는 이런 전송 반복적인 작업들을 피하기 위해 command-line 기반으로 어떻게 자동화를 할 수 있을 지 알아보다 발견한 툴이다.이미 Putty 를 쓰고 있다면 Putty 에 포함되어 있는 프로그램이고, 다운로드 받고 싶다면 아래 링크에서 받을 수 있다. Download link 그리고, 아래와 같이 사용하면 된다. 사용법도 간단하고 pw 를 지정할 수도 있어서 자동화할 때 좋다. 1234# 192.168.11.10 의 host 로 접속해서 pwd 명령plink.exe -ssh -pw &lt;password&gt; host@192.168.11.10 &quot;pwd&quot;# 192.168.11.10 의 ~/dest 폴더로 example.txt 를 복사pscp.exe -scp -r -pw &lt;password&gt; example.txt host@192.168.11.10:~/dest","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"SSH","slug":"ssh","permalink":"https://yhwanp.github.io/tags/ssh/"},{"name":"SCP","slug":"scp","permalink":"https://yhwanp.github.io/tags/scp/"},{"name":"Automation","slug":"automation","permalink":"https://yhwanp.github.io/tags/automation/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"일론 머스크의 뉴럴링크, 뇌와 컴퓨터의 연결","slug":"elon-musk-neuralink","date":"2019-08-25T13:31:10.000Z","updated":"2019-08-25T19:54:20.044Z","comments":true,"path":"2019/08/25/elon-musk-neuralink/","link":"","permalink":"https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/","excerpt":"","text":"일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자 영상의 내용을 아주 간단하게 요약하자면, 뉴럴링크란 뇌의 대뇌피질에 작은 칩을 연결해 뇌의 뉴런들이 전달하는 전자기적 신호를 알고리즘으로 분석해서 사람의 생각, 감각, 운동능력 등에 영향을 줄 수 있는 기술이다.1차적으로 파킨슨병 같은 뇌 질환을 앓고 있는 환자들을 위해 사용될 것이고, 2020년 말에는 일반인들에게도 상용화가 될 것이라고 예상한다고 한다. 뉴럴링크가 상용화된다면, 이제 더 이상 마우스나 키보드, 모니터 와 같은 뇌와 컴퓨터간의 입력 매체 및 출력매체가 필요 없어질 수 있다. 다양한 입력 매체의 도움없이도 훨씬 빠르게, 내가 생각하는 속도로 컴퓨터를 조작하고, 출력 매체가 없이도 얻고자 하는 정보를 뇌에 주입 시킬 수도 있는 것이다. 사람들은 인공지능 컴퓨터의 도움으로 현재보다 훨씬 많은 정보를 빠르고 쉽게 습득할 수 있을 것이다. 과연 2020년 말에는 생각만으로 상호작용을 하는 고도화된 인공지능 비서를 가질 수 있을까? 아직은 전혀 실감이 나지 않지만 동물을 통한 실험도 어느정도 진행되었고 유의미한 성과를 이룬 것으로 보인다. 인간에게 적용되었을 때 안전성 / 보안성 문제만 해결된다면, 특이점을 불러올 기술이라고 생각된다.뉴럴링크는 기존의 지식, 인프라를 무너뜨릴 수도 있을 것이다. 한편으론 내가 수년 간 쌓은 지식, 경험이 이 기술이 개발됨에 따라 남들이 쉽게 따라할 수 있다고 생각하면 당장 의욕이 떨어질 수도 있겠다. 하지만 이런 시대가 올 수 있다고 아직 장담할 수 없는 단계이고, 당장 할 수 있는 것도 없다. 그저 경각심을 가지고 현실을 열심히 살면 뉴럴링크 의 시대에도 내가 할 수 있는 것이 있을 것이라고 믿고, 준비해야 한다고 생각한다.","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"Neuralink","slug":"neuralink","permalink":"https://yhwanp.github.io/tags/neuralink/"},{"name":"Elon Musk","slug":"elon-musk","permalink":"https://yhwanp.github.io/tags/elon-musk/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"iTerm2 3.3 release 이후 Theme 변경 및 Status Bar 사용하기","slug":"iterm2-3-3-update","date":"2019-08-21T16:36:27.000Z","updated":"2019-08-21T17:15:19.435Z","comments":true,"path":"2019/08/22/iterm2-3-3-update/","link":"","permalink":"https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/","excerpt":"","text":"새롭게 추가된 Minimal Theme하단의 Try it now 를 클릭하면 자동으로 변경됩니다. 이전 기본 테마보다 훨씬 깔끔하네요. 다시 이전 테마로 돌아가고 싶다면 Preferences - Appearance 에서 변경 할 수 있습니다. Status Bar 표시status bar 는 개인설정이 가능합니다. 배터리, CPU, RAM 사용량, 네트워크 대역폭 등 여러 정보 및 Tool 을 status bar 에 설정할 수 있네요. 개인 설정까지 완료된 모습","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}],"tags":[{"name":"iTerm2","slug":"iterm2","permalink":"https://yhwanp.github.io/tags/iterm2/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"}]},{"title":"CMake 에서 상대경로를 절대경로로 바꾸기","slug":"cmake-convert-to-absolute-path","date":"2019-08-21T15:57:53.000Z","updated":"2019-08-21T16:14:39.261Z","comments":true,"path":"2019/08/22/cmake-convert-to-absolute-path/","link":"","permalink":"https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/","excerpt":"","text":"CMake 에서 상대경로를 절대경로로 바꿔보자 왜 필요한가? CMake 에서 지원하는 여러 명령들 중에 상대 경로로 입력하면 오류가 출력되는 function 들이 있습니다.이때, 상대 경로를 절대 경로로 변환하기 위해 get_filename_component 을 사용하면 됩니다. 원형: 1get_filename_component(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE]) 아래는 ../../.. 에 해당하는 상대경로를 절대경로로 변환해서, MY_ABSOLUTE_PATH 라는 변수로 저장 시키는 예제 입니다. 1get_filename_component(MY_ABSOLUTE_PATH &quot;../../..&quot; ABSOLUTE)","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"CMake","slug":"etc/cmake","permalink":"https://yhwanp.github.io/categories/etc/cmake/"}],"tags":[{"name":"CMake","slug":"cmake","permalink":"https://yhwanp.github.io/tags/cmake/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"CMake","slug":"etc/cmake","permalink":"https://yhwanp.github.io/categories/etc/cmake/"}]},{"title":"OpenSSL을 NDK로 빌드하기","slug":"OpenSSL을-NDK로-빌드하기","date":"2019-07-28T10:02:06.000Z","updated":"2019-07-28T10:43:14.047Z","comments":true,"path":"2019/07/28/OpenSSL을-NDK로-빌드하기/","link":"","permalink":"https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/","excerpt":"","text":"시작에 앞서보통 실습 용도나 로컬에서 테스트를 할 경우에는 Precompiled library 를 사용해도 되지만 상용 프로그램에 포함할 경우 암호화 알고리즘 라이센스 문제가 발생할 수 있습니다.문제가 되는 암호화 알고리즘을 제외한 Precompiled library 가 있으면 해결되지만, 특정 NDK, OpenSSL 버전을 맞춰야 하는 경우 이에 만족하는 라이브러리를 찾기가 힘들어서, 직접 빌드하는 편이 빠릅니다. 빌드 환경 및 사용 버전 NDK r18b OpenSSL 1.0.2l Ubuntu 18.04 빌드 시작하기 NDK 이용해 custom toolchain 생성 (https://developer.android.com/ndk/guides/standalone_toolchain) 1python3 $NDK/build/tools/make_standalone_toolchain.py --arch arm64 --api 26 --install-dir /opt/android-26-arm64 OpenSSL 폴더로 이동 1cd openssl-1.0.2l Clang 에서 &#39;-mandroid&#39; 를 지원하지 않으므로 Configure 파일에서 해당 부분 삭제 1sed -i -e &#x27;s/-mandroid//&#x27; Configure Confiigure 시작 1CROSS_COMPILE=/opt/android-26-arm64/bin/aarch64-linux-android- ./Configure android shared no-idea no-mdc2 no-rc5 make 시작 12make dependmake ANDROID_DEV=/opt/android-26-arm64/sysroot/usr CALC_VERSIONS=&quot;SHLIB_COMPAT=; SHLIB_SOVER=&quot; build_libs 생성된 library 가 올바르게 빌드 됐는지 확인 1readelf -h ./libcrypto.a | grep -i &#x27;class\\|machine&#x27; | head -2","categories":[{"name":"Android","slug":"android","permalink":"https://yhwanp.github.io/categories/android/"},{"name":"NDK","slug":"android/ndk","permalink":"https://yhwanp.github.io/categories/android/ndk/"}],"tags":[{"name":"Android","slug":"android","permalink":"https://yhwanp.github.io/tags/android/"},{"name":"NDK","slug":"ndk","permalink":"https://yhwanp.github.io/tags/ndk/"},{"name":"OpenSSL","slug":"openssl","permalink":"https://yhwanp.github.io/tags/openssl/"}],"keywords":[{"name":"Android","slug":"android","permalink":"https://yhwanp.github.io/categories/android/"},{"name":"NDK","slug":"android/ndk","permalink":"https://yhwanp.github.io/categories/android/ndk/"}]},{"title":"Hexo 블로그 폰트 사이즈 수정하기 - (Hueman 테마)","slug":"Hexo-블로그-폰트-사이즈-수정하기-Hueman-테마","date":"2019-07-28T09:17:21.000Z","updated":"2021-10-04T11:14:09.836Z","comments":true,"path":"2019/07/28/Hexo-블로그-폰트-사이즈-수정하기-Hueman-테마/","link":"","permalink":"https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/","excerpt":"","text":"블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)앞서 Hexo-blog-셋팅-정리 에서 소개한 블로그들에서 소개되지 않은 부분이 있는데, 바로 게시글의 폰트 사이즈를 수정하는 방법입니다.기본 사이즈는 18px 로 설정되어 있는데, 미묘하게 큰 사이즈여서 포스트가 한 눈에 들어오지 않는 것 같아 사이즈를 수정했습니다. 수정하기 위해서 /$HEXO_HOME/themes/hueman/source/css/_variables.styl 파일을 엽니다.그리고, font-size-article 을 찾아서 원하는 사이즈로 수정합니다. 12//font-size-article = 18pxfont-size-article = 17px","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://yhwanp.github.io/tags/hexo/"},{"name":"Font","slug":"font","permalink":"https://yhwanp.github.io/tags/font/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}]},{"title":"Hexo 블로그 셋팅 총정리","slug":"Hexo-blog-setting","date":"2019-07-27T12:30:51.000Z","updated":"2019-09-03T17:36:59.158Z","comments":true,"path":"2019/07/27/Hexo-blog-setting/","link":"","permalink":"https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/","excerpt":"","text":"Hexo 블로그 만들기hexo 블로그를 만들기 위해 참고했던 사이트를 정리해보려 합니다.아래에 있는 블로그만 참조해도 꽤 괜찮은 블로그를 만들 수 있습니다.그 중에서도 Eric Han 님의 블로그의 글이 포스팅 된 지 가장 오래된 글임에도 많은 도움이 됐습니다. 튜토리얼 with Hueman 테마Eric Han’s IT Blog Powered by Hexod2fault 튜토리얼 with Tranquilpeak 테마밍피디 Markdown 문법MarkDown 사용법 총정리 190904 Update Category 나 Tag 클릭 시 404 error 해결법처음 글 썼을 때 생성한 Category 나 Tag 에서 소문자/대문자를 바꿨을 때 이를 인식하지 못 해서 발생하는 문제. 링크에 대해선 대-소문자 구분 없이 통일하는 것이 좋음.Hexo 블로그에서 카테고리(태그)가 제대로 보이지 않을 때","categories":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://yhwanp.github.io/tags/hexo/"},{"name":"Markdown","slug":"markdown","permalink":"https://yhwanp.github.io/tags/markdown/"}],"keywords":[{"name":"ETC","slug":"etc","permalink":"https://yhwanp.github.io/categories/etc/"},{"name":"Hexo","slug":"etc/hexo","permalink":"https://yhwanp.github.io/categories/etc/hexo/"}]}]}