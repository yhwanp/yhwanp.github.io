<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhwanp&#39;s devNote</title>
    <link>https://yhwanp.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>yhwanp&#39;s devNote</description>
    <pubDate>Mon, 30 Dec 2019 18:09:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Codility 4-4 MaxCounters</title>
      <link>https://yhwanp.github.io/2019/12/30/codility-4-4-maxcounters/</link>
      <guid>https://yhwanp.github.io/2019/12/30/codility-4-4-maxcounters/</guid>
      <pubDate>Mon, 30 Dec 2019 14:57:32 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codility.com/programmers/lessons/4-counting_elements/max_counters/&quot; rel=&quot;external nofollow noopener norefer
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://codility.com/programmers/lessons/4-counting_elements/max_counters/" rel="external nofollow noopener noreferrer" target="_blank">Codility 4-4 MaxCounters</a></p></blockquote><p><em>For example, given integer N = 5 and array A such that:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A[0] = 3   </span><br><span class="line">A[1] = 4    </span><br><span class="line">A[2] = 4    </span><br><span class="line">A[3] = 6    </span><br><span class="line">A[4] = 1    </span><br><span class="line">A[5] = 4    </span><br><span class="line">A[6] = 4</span><br></pre></td></tr></table></figure><p><em>the values of the counters after each consecutive operation will be:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0, 0, 1, 0, 0)    </span><br><span class="line">(0, 0, 1, 1, 0)    </span><br><span class="line">(0, 0, 1, 2, 0)    </span><br><span class="line">(2, 2, 2, 2, 2)    </span><br><span class="line">(3, 2, 2, 2, 2)    </span><br><span class="line">(3, 2, 2, 3, 2)    </span><br><span class="line">(3, 2, 2, 4, 2)</span><br></pre></td></tr></table></figure><p><em>The goal is to calculate the value of every counter after all operations.</em></p><p>시간복잡도 때문에 77% 에서 100%<br>최초에 짰을때는 문제그대로 시뮬레이션 해서 1~N 까지의 값일땐 해당 인덱스의 값을 ++ 해주고<br>N+1 일때 모든 인덱스의 값을 max값으로 채워줬음.<br>이때 모든 인덱스의 값을 채워주는 과정에서 시간이 N만큼 들어서 시간 복잡도가 A.length * N 되어버림.</p><p>그래서 min 값을 따로 두고<br>해당 인덱스의 값이 min 보다 크거나 같을경우 ++ ,<br>min 보다 작을경우 min+1 으로 대입해줌<br>이렇게 해주면 N+1 을 만날때마다 모든 인덱스의 값을 채우는 비효율을 개선할 수 있음.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span> N, <span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="comment">// write your code in Java SE </span></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == N+<span class="number">1</span>) &#123;</span><br><span class="line">            min = max;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(min &lt;= ans[A[i]-<span class="number">1</span>])</span><br><span class="line">                ans[A[i]-<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[A[i]-<span class="number">1</span>] = min+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span>(ans[A[i]-<span class="number">1</span>] &gt; max)</span><br><span class="line">                max = ans[A[i]-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &lt; min)</span><br><span class="line">            ans[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/30/codility-4-4-maxcounters/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ const 와 constexpr</title>
      <link>https://yhwanp.github.io/2019/12/25/const-and-constexpr/</link>
      <guid>https://yhwanp.github.io/2019/12/25/const-and-constexpr/</guid>
      <pubDate>Wed, 25 Dec 2019 14:34:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;const&quot;&gt;&lt;a href=&quot;#const&quot; class=&quot;headerlink&quot; title=&quot;const&quot;&gt;&lt;/a&gt;const&lt;/h3&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 를 선언함으로서 값을 고정할 수 있다.&lt;br&gt;실수를 줄일 수 있기 때문
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code> 를 선언함으로서 값을 고정할 수 있다.<br>실수를 줄일 수 있기 때문에 const 를 쓸 수 있는 상황에서는 무조건 사용하는 게 좋다.<br>아래와 같은 쓰임새가 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 파라메터를 const 로 해서, 함수 내부에서 inpString을 변경하지 못하게 함</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; inpString)</span></span>;</span><br><span class="line">  <span class="comment">// 리턴을 const 로 해서, 외부에서 멤버 str 을 변경하지 못하게 함</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getStringRef</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// print 만 수행하는 함수이므로 함수 내부에서 멤버 변수를 변경하지 못하게 함</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>C++11 에 도입된 것으로, const 와 비슷하지만  <code>constexpr</code> 은 <code>Compile time</code>에 값이 결정되기를 원할 때 사용한다. 또 compile time 에 값을 결정하는 방법으로는 <code>템플릿 메타 프로그래밍</code>을 이용하는 방법이 있는데 가독성이나 사용성면에서나 constexpr 로 사용하는 것이 좋겠다.</p><p>그런데 함수를 constexpr 로 선언하더라도 compile time 에 결정될 수 있고 runtime 에 결정될 수도 있다. 이는 컴파일러의 어떤 평가 기준에 따라 결정 되는데 항상 compile time 에 결정되기 원하는 값이라면 리턴을 받는 변수를 constexpr 로 선언하면 된다.<br>연산량이 너무 많다면 compile time 에 결정하지 못할 수도 있다. (Compile error 발생)<br>아래 코드를 보면서 이해해보자.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "constexpr int retVal" 로 받기 때문에 compile time 에 결정한다.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> retVal = Factorial(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수를 사용할 시 runtime 에 결정</span></span><br><span class="line"><span class="keyword">int</span> a = getInp;</span><br><span class="line"><span class="keyword">int</span> retVal = Factorial(a);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/25/const-and-constexpr/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Web IDE 추천</title>
      <link>https://yhwanp.github.io/2019/12/20/c-web-ide/</link>
      <guid>https://yhwanp.github.io/2019/12/20/c-web-ide/</guid>
      <pubDate>Thu, 19 Dec 2019 15:57:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;코딩을 하다보면 내가 짜는 코드가 실제로 어떻게 동작하는지 헷갈리거나 컴파일러 별로 동작이 다른 부분을 직접 확인해보고 싶을 때가 있는데, 그럴 때 Web IDE 를 사용하는 편이다.&lt;br&gt;속도도 빠른 편이고, 컴파일러 선택 옵션이나 기능들도 충
        
      
      </description>
      
      <content:encoded><![CDATA[<p>코딩을 하다보면 내가 짜는 코드가 실제로 어떻게 동작하는지 헷갈리거나 컴파일러 별로 동작이 다른 부분을 직접 확인해보고 싶을 때가 있는데, 그럴 때 Web IDE 를 사용하는 편이다.<br>속도도 빠른 편이고, 컴파일러 선택 옵션이나 기능들도 충분하다고 생각된다.<br>작성한 C++ code 를 실시간으로 assembly code 로 보여주는 기능도 있어서, assembly 를 배우는 목적으로 사용해도 괜찮을 것 같다.  </p><p><a href="https://gcc.godbolt.org" rel="external nofollow noopener noreferrer" target="_blank">https://gcc.godbolt.org</a><br><img src="image-20191230010744241.png" alt></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/20/c-web-ide/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ubuntu 18.04 DNS 설정하기 (초기화 문제 해결)</title>
      <link>https://yhwanp.github.io/2019/12/16/ubuntu-dns-setting/</link>
      <guid>https://yhwanp.github.io/2019/12/16/ubuntu-dns-setting/</guid>
      <pubDate>Sun, 15 Dec 2019 15:54:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Linux OS의 DNS 셋팅하기 위해서 일반적으로 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 를 수정하는데,&lt;br&gt;Ubuntu 18.04 환경에서 수정 후 도메인 서버가 변경은 되는데, 재부팅 후 다시 초기화 되는 현상이 있어 불편하
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Linux OS의 DNS 셋팅하기 위해서 일반적으로 <code>/etc/resolv.conf</code> 를 수정하는데,<br>Ubuntu 18.04 환경에서 수정 후 도메인 서버가 변경은 되는데, 재부팅 후 다시 초기화 되는 현상이 있어 불편하게 사용하다가 해결한 방법을 정리한다.</p><p>구글링 해보면 다양한 해결 방법이 있는데, 이 방법이 가장 올바른 수정 방법으로 보인다.<br>/etc/resolv.conf 를 열어보면 주석으로 generated 된 파일이며, 수동으로 변경하지 말 것을 권하고 있다.<br>Ubuntu 18.04 에서는 <code>systemd-resolved</code> 를 사용하기 때문에 아래 파일을 수정하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/resolved.conf</span><br></pre></td></tr></table></figure><p>옵션들에 대한 자세한 설명은 <a href="https://wiki.archlinux.org/index.php/Systemd-resolved" rel="external nofollow noopener noreferrer" target="_blank">wiki page</a> 를 참고한다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/16/ubuntu-dns-setting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C/C++ free/delete 없이 프로그램을 종료한다면?</title>
      <link>https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/</link>
      <guid>https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/</guid>
      <pubDate>Sat, 14 Dec 2019 11:04:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;code&gt;delete&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt; 는 C++/C 개발할 때 꼭 빼먹어서는 안되는 중요한 키워드이다.&lt;br&gt;관련해서 학부 시절에 실습 과제를 제출하는 시스템이 있었다.&lt;br&gt;어려운 실습 과제에 허덕이던 동기들끼리 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><code>delete</code>/<code>free</code> 는 C++/C 개발할 때 꼭 빼먹어서는 안되는 중요한 키워드이다.<br>관련해서 학부 시절에 실습 과제를 제출하는 시스템이 있었다.<br>어려운 실습 과제에 허덕이던 동기들끼리 농담으로 “<code>malloc</code> 으로 동적할당을 크게 잡아버리고 <code>free</code> 안해서 서버 다운시켜 버리자.” 라는 얘기를 한 적이 있다.</p><p>그 당시에는 잘 몰라서 위와 같이 코딩해서 제출하면 정말 서버가 다운되는 줄 알았지만<br>실제로는 그럴 일은 드물다.<br>왜냐면, 최근의 <code>OS</code> 들은 process 종료 시 사용중인 memory 를 자동으로 <code>반환</code>한다.<br>따라서 일반적인 경우 program lifecycle 이 끝난 뒤에는 memory 를 자동으로 반환 시켜줄 것이다. (그리고.. 과제 제출 시스템은 cpu / memory 사용량을 제어하는 cgroup 과 같은 시스템이 있지 않았을까..?)</p><p>그런데 이와같이 메모리 해제를 OS 에 의지하는 것은 나쁜 습관이다.<br>알고리즘 과제 혹은 간단한 컨버팅 프로그램 같이 몇초 내에 끝내는 간단한 로직이라면 문제가 발생하진 않겠지만 이보다 큰 스케일의 프로그램에 우리가 메모리 해제 없이 코딩한 프로그램을 이식시켜야 하는 상황이 온다면, 그리고 그 프로그램이 오랫동안 길게 동작하는 프로그램이라면 프로그램 실행중에 <code>memory leak</code> 이 발생할 것이고 점점 시스템 자원을 갉아먹어서 프로그램을 재시작 해야 하는 상황까지 오게 될 것이다.<br>어떤 프로그램을 사용할 때 처음 실행했을 때는 빠릿빠릿한데, 점점 사용하다보면 느려졌던 경우가 다들 한번씩은 있었을 것이다. 보통 최적화 문제가 있는 게임에서 이런 현상을 경험하는 유저들이 많다. 이런 경우가 자원 관리가 되지 않아서 발생하는 문제일 것이다.</p><p>그리고 또 한 가지는 메모리 해제를 명시적으로 해주면 클래스의 소멸 순서를 보장할 수 있기 때문에 이는 개발자의 의도대로 프로그램이 안정적으로 종료되는 것에 도움이 된다.</p><p>요약 정리</p><ol><li>Process 종료 시 Operating System 은 Process 가 사용중인 메모리를 자동으로 모두 반환 시킨다.</li><li>그렇지만 위와 같이 OS에 메모리 해제를 맡기는 습관은 잘 못된 습관이다.<br>왜냐하면 우리는 앞으로 충분히 긴 시간 동안 동작하는 프로그램도 짜야하며, 이식성 좋고 안정적인 프로그램을 짜야한다.</li></ol>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ try-catch 예외처리와 성능</title>
      <link>https://yhwanp.github.io/2019/12/10/c-try-catch-exeption-with-performance/</link>
      <guid>https://yhwanp.github.io/2019/12/10/c-try-catch-exeption-with-performance/</guid>
      <pubDate>Mon, 09 Dec 2019 17:36:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;C++ 에서 &lt;code&gt;예외처리&lt;/code&gt;는 overhead 가 있다는 것은 익히 알고 있을 것이다.&lt;br&gt;그럼에도 &lt;code&gt;try-catch&lt;/code&gt; 구문이 꼭 필요한 경우가 있는데, overhead 가 있다는 것이 예상만 되지 &lt;cod
        
      
      </description>
      
      <content:encoded><![CDATA[<p>C++ 에서 <code>예외처리</code>는 overhead 가 있다는 것은 익히 알고 있을 것이다.<br>그럼에도 <code>try-catch</code> 구문이 꼭 필요한 경우가 있는데, overhead 가 있다는 것이 예상만 되지 <code>exception</code> 발생 유무에 따른 성능 차이에 대해서 궁금해져서 성능 상 얼마나 차이가 있을지 찾아보았다.</p><p>결론은 ‘<code>try-catch</code> 를 사용하더라도, <code>exception</code> 이 실제로 발생하지 않거나, 거의 발생하지 않는다면 성능에 영향은 거의 없다’ 이다. 위와 같은 경우에는 사용 시 괜한 걱정하지 않아도 된다.</p><p>아래 정말 자세하게 테스트한 실험글이 있어서, 좀 더 자세한 데이터를 원하면 아래를 참고.<br><a href="https://yesarang.tistory.com/371" rel="external nofollow noopener noreferrer" target="_blank">C++ 이야기 서른두번째: 예외가 성능에 미치는 영향</a></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/12/10/c-try-catch-exeption-with-performance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Korea 6th Semina 후기 (2019-09-29)</title>
      <link>https://yhwanp.github.io/2019/10/06/cpp-korea-6th-semina/</link>
      <guid>https://yhwanp.github.io/2019/10/06/cpp-korea-6th-semina/</guid>
      <pubDate>Sun, 06 Oct 2019 12:18:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2019-09-29 일요일에 C++ Korea 에서 주최하는 Semina 가 있었다.&lt;br&gt;보통 이런 세미나들이 다 그렇듯이 서울에서 열려서, 부산에 사는 입장에선 차비, 숙박비 등 합치면 돈도 꽤 들고, 이동 시간도 많이 소요돼서 조금 고민되긴
        
      
      </description>
      
      <content:encoded><![CDATA[<p>2019-09-29 일요일에 C++ Korea 에서 주최하는 Semina 가 있었다.<br>보통 이런 세미나들이 다 그렇듯이 서울에서 열려서, 부산에 사는 입장에선 차비, 숙박비 등 합치면 돈도 꽤 들고, 이동 시간도 많이 소요돼서 조금 고민되긴 했었으나 요즘 C++ 을 주제로 하는 세미나는 거의 없고, session 내용을 보니 들어보고 싶은 내용이 많아서 참석하게 됐다.</p><p><img src="image-20191006214314417.png" alt="https://festa.io/events/528"></p><br><p>세미나 장소는 광화문에 있는 마이크로소프트 코리아였다.</p><p><img src="dBs+ptlbS0i4jYGimsP5JA_thumb_23b.jpg" alt="Microsoft Korea 입구"></p><p><img src="image-20191006215423518.png" alt="경복궁이 한눈에 보이는 경치! 뷰가 정말 좋다."></p><p><img src="C0AAFD29-BC2D-4185-BFD4-3299D0083250_1_105_c.jpeg" alt="세션 내용"></p><p>내용은 모두 만족스럽고 재밌었다. 지금은 모던 C++ 쪽 경험이 별로 없어서 모던 쪽은 잘 모르는데 개인적으로 사용해보고 싶어지고 흥미가 생기는 내용이었다. 인상깊었던 내용들은 다시 블로그에 정리해볼 생각이다.<br>별 일 없다면 다음 C++ Korea 세미나도 참석할 것 같다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/10/06/cpp-korea-6th-semina/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ std::function 와 std::bind 사용법</title>
      <link>https://yhwanp.github.io/2019/09/15/std-function-and-std-bind/</link>
      <guid>https://yhwanp.github.io/2019/09/15/std-function-and-std-bind/</guid>
      <pubDate>Sun, 15 Sep 2019 14:17:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;std-function-란&quot;&gt;&lt;a href=&quot;#std-function-란&quot; class=&quot;headerlink&quot; title=&quot;std::function 란?&quot;&gt;&lt;/a&gt;std::function 란?&lt;/h2&gt;&lt;p&gt;C++11 부터 추가된 기능으로,
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="std-function-란"><a href="#std-function-란" class="headerlink" title="std::function 란?"></a>std::function 란?</h2><p>C++11 부터 추가된 기능으로, C의 함수 포인터를 대체한다.<br>아래와 같이 사용할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAndPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = a + b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = addAndPrint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래 두 줄은 똑같이 작동한다</span></span><br><span class="line">addAndPrint(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">func1(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>위에선 전역으로 선언된 addAndPrint 함수를 std::function 으로 받고 있다.<br>만약 class 의 멤버함수를 가르키고 싶으면, 위와는 조금 다르게 사용해야 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAndPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A test;</span><br><span class="line"><span class="comment">// 매개변수로 객체를 전달해야한다</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(A&amp;, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func3 = &amp;A::addAndPrint;</span><br><span class="line">func3(test, <span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>위처럼 멤버함수를 위해서 어떤 객체의 멤버함수를 실행할 지 알 수 있도록 객체를 전달해야 한다.<br>그리고 13번째 줄에서 A의 addAndPrint 를 대입하기 위해 &amp;A::addAndPrint 처럼 앞에 &amp; 를 사용하고 있는데, 이 이유는 멤버함수의 경우엔 함수의 주소값으로 암시적 형변환이 되지 않아서, 명시적으로 &amp;를 사용해서 주소값을 전달해줘야 하기 때문이다.</p><h2 id="std-bind-란"><a href="#std-bind-란" class="headerlink" title="std::bind 란?"></a>std::bind 란?</h2><p>std::function 과 마찬가지로 C++11 기능이며, 함수의 인자를 지정할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAndPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = a + b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func2 = <span class="built_in">std</span>::bind(addAndPrint, <span class="number">10</span>, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">func2(<span class="number">100</span>);<span class="comment">// addAndPrint(10, 100); 과 동일한 결과를 보장함</span></span><br></pre></td></tr></table></figure><p>위 코드부턴 auto 를 사용했는데, 여기선 std::function&lt;void(int)&gt; 와 동일하다.<br>std::bind(addAndPrint, 10, std::placeholders::_1) 의 의미는 addAndPrint(int, int) 함수의 첫 번째 파라메터는 10, 두 번째 파라메터는 func2 를 호출할 때 들어오는 첫번째 인자를 넣어준다는 의미다.</p><p>클래스 멤버함수를 클래스 내부에서 bind 시켜주는 예제를 한번 작성해보자</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAndPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindFunction</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&amp; dest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dest = <span class="built_in">std</span>::bind(&amp;A::addAndPrint, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A test;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func4;</span><br><span class="line">test.bindFunction(func4);</span><br><span class="line">func4(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>func4는 객체 바깥에서 선언되고, A::bindFunction 에 의해서 test.addAndPrint 와 동일한 동작을 하는 함수로 bind 되었다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/15/std-function-and-std-bind/#disqus_thread</comments>
    </item>
    
    <item>
      <title>lsof - open 된 파일에 대한 정보 출력</title>
      <link>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/</link>
      <guid>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/</guid>
      <pubDate>Sun, 15 Sep 2019 13:00:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;lsof-란&quot;&gt;&lt;a href=&quot;#lsof-란&quot; class=&quot;headerlink&quot; title=&quot;lsof 란 ?&quot;&gt;&lt;/a&gt;lsof 란 ?&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 는 &lt;code&gt;List Open Files&lt;/code&gt; 의
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="lsof-란"><a href="#lsof-란" class="headerlink" title="lsof 란 ?"></a>lsof 란 ?</h2><p><code>lsof</code> 는 <code>List Open Files</code> 의 약자이고, 시스템에서 열린 파일 목록을 보여준다.<br>여러가지 옵션이 많지만 주로 아래 명령어들만 사용했다.</p><p>특히 특정 프로세스가 file 을 열고 닫지 않아서 발생하는 error 및 crash 를 잡을 때 <code>lsof - p</code>  를 이용하면 어떤 파일을 닫지 않아 <code>fd leak</code> 이 발생하는지 알 수 있어서 코드 상 수정해야할 부분을 캐치하기 쉽다.<br>또 소켓 프로그래밍을 하는 경우엔 포트 점유 목록을 출력하는 명령어가 도움이 될 수 있겠다.</p><p>A. 열린 파일 목록 모두 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>B. 특정 프로세스의 열린 파일 목록 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 다음에 pid 를 입력하면 된다</span></span><br><span class="line">lsof -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>C. TCP 포트 점유 목록 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 아래는 22번 TCP 포트를 점유하는 pid 및 fd 를 출력한다</span></span><br><span class="line">lsof -i TCP:22</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ std::vector push_back 보단 emplace_back 을 사용하자</title>
      <link>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/</link>
      <guid>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/</guid>
      <pubDate>Sun, 08 Sep 2019 16:58:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;emplace-back-을-사용하자&quot;&gt;&lt;a href=&quot;#emplace-back-을-사용하자&quot; class=&quot;headerlink&quot; title=&quot;emplace_back 을 사용하자&quot;&gt;&lt;/a&gt;emplace_back 을 사용하자&lt;/h2&gt;&lt;p&gt;&lt;c
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="emplace-back-을-사용하자"><a href="#emplace-back-을-사용하자" class="headerlink" title="emplace_back 을 사용하자"></a>emplace_back 을 사용하자</h2><p><code>emplace_back</code> 은 c++11 에 추가된 std::vector 의 멤버함수다.<br>보통 vector 에 값을 넣을 때, 아래와 같이 <code>push_back</code> 을 사용할 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strList;</span><br><span class="line"><span class="comment">// 이렇게 객체를 하나 선언해서 넣거나</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> A = <span class="string">"test"</span>;</span><br><span class="line">strList.push_back(A); </span><br><span class="line"><span class="comment">// 임시 객체를 바로 전달하는 방식</span></span><br><span class="line">strList.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure><p>위와 같이 작성하는 것이 일반적이지만 성능 측면에서 봤을 때 <code>emplace_back</code> 을 사용하는 것이 훨씬 효과적이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strList;</span><br><span class="line">strList.emplace_back(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pair 나 생성자가 있는 다른 모든 class 도 가능</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pairList;</span><br><span class="line">pairList.emplace_back(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><code>push_back</code> 을 사용할 때는 vector 에 값을 넣기 위해 바깥에서 임시 객체의 생성자 / 소멸자가 호출되고 vector 내부에 복사되는 과정에서 또 객체가 한번 더 생성이 되지만,<br><code>emplace_back</code> 을 사용하면, 생성자의 인자 value 들만 전달해주면 vector 내부에서 한번만 객체 생성을 한다.</p><p>거의 대부분의 경우에서 <code>emplace_back</code> 을 사용하는 경우의 속도가 더 빠르고 <code>push_back</code> 을 완벽히 대체할 수 있어서 <code>emplace_back</code> 사용을 권장한다고 한다. 프로젝트에서 C++11 이상을 사용한다면 <code>emplace_back</code> 사용을 고려해보자.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ubuntu SSH Welcome message 추가하기</title>
      <link>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/</link>
      <guid>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/</guid>
      <pubDate>Sun, 08 Sep 2019 10:59:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;client 가 SSH 에 접속할 때마다 출력되는 &lt;code&gt;Welcome message&lt;/code&gt; 를 추가하는 방법이다.&lt;br&gt;&lt;em&gt;(Ubuntu 18.04 기준)&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t
        
      
      </description>
      
      <content:encoded><![CDATA[<p>client 가 SSH 에 접속할 때마다 출력되는 <code>Welcome message</code> 를 추가하는 방법이다.<br><em>(Ubuntu 18.04 기준)</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/update-motd.d 에 99-custom 을 생성해줌.</span></span><br><span class="line">vi /etc/update-motd.d/99-custom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 내용 예제</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"### 내용 입력 ###"</span></span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>who 는 현재 SSH connect 되어있는 client 목록을 보여준다.<br>출력하고 싶은 내용을 자유롭게 입력하면 된다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Rvalue 와 std::move 에 대한 이해</title>
      <link>https://yhwanp.github.io/2019/09/08/rvalue-and-move/</link>
      <guid>https://yhwanp.github.io/2019/09/08/rvalue-and-move/</guid>
      <pubDate>Sun, 08 Sep 2019 09:23:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Rvalue-란-무엇인가&quot;&gt;&lt;a href=&quot;#Rvalue-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;Rvalue 란 무엇인가?&quot;&gt;&lt;/a&gt;Rvalue 란 무엇인가?&lt;/h2&gt;&lt;p&gt;Rvalue, 우측값은 대입 시에 항상 오른
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Rvalue-란-무엇인가"><a href="#Rvalue-란-무엇인가" class="headerlink" title="Rvalue 란 무엇인가?"></a>Rvalue 란 무엇인가?</h2><p>Rvalue, 우측값은 대입 시에 항상 오른쪽에만 오는 식을 말한다.<br>예제로 이해하는 것이 쉽다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;<span class="comment">// x 는 Lvalue, 10은 Rvalue</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">20</span>;<span class="comment">// y 는 Lvalue, 20은 Rvalue</span></span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// x 와 y 모두 Lvalue</span></span><br><span class="line">x = (x + y);<span class="comment">// x 는 Lvalue, x + y 는 Rvalue</span></span><br><span class="line"></span><br><span class="line">x + y = <span class="number">30</span>;<span class="comment">// 잘 못된 코드, Rvalue 인 x + y 에 대입하고 있다.</span></span><br><span class="line"></span><br><span class="line">x = doSomething()<span class="comment">// doSomething() 은 Rvalue</span></span><br></pre></td></tr></table></figure><p>x, y 처럼 이름을 가지고 있고, 그 이름으로 접근할 수 있는 것이 Lvalue 이다.<br>그와 반대로 (x + y) 나 상수 10, 20 등은 이름을 가지고 있지 않고 식이 끝난 후 다음 라인에서 그 값에 접근할 수 없다.</p><p>Rvalue 를 함수의 매개변수로 받고 싶으면 A&amp;&amp; 로 선언한다.<br>참고로 doSomethingWithRvalue 안에서 rhs 를 다시 사용할 때는 rhs 가 Lvalue 라는 것을 주의하자. Rvalue 로 사용하고 싶으면 다시 std::move(rhs) 와 같이 사용해주어야 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="comment">// class A의 instance를 Rvalue 로 받고 싶을 때</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomethingWithRvalue</span><span class="params">(A&amp;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-move-를-사용해서-성능을-개선해보자"><a href="#std-move-를-사용해서-성능을-개선해보자" class="headerlink" title="std::move 를 사용해서 성능을 개선해보자"></a>std::move 를 사용해서 성능을 개선해보자</h2><p><code>std::move</code> 는 이름 때문에 부르는 것과 동시에 어떤 이동 작업이 이뤄질 것 같지만, 실제로 Lvalue 를 Rvalue 로 casting 해줄 뿐이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  myClass()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  myClass(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span><br><span class="line">  : data(str)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">myClass <span class="title">A</span><span class="params">(<span class="string">"aaa"</span>)</span></span>;</span><br><span class="line">myClass B;</span><br><span class="line">myClass C;</span><br><span class="line"></span><br><span class="line">B = A;</span><br><span class="line">C = <span class="built_in">std</span>::move(A);<span class="comment">// Lvalue 인 A를 Rvalue 로 casting</span></span><br></pre></td></tr></table></figure><p><em>(std::string 은 실제 작은 문자열은 stack memory 에 저장하고 큰 문자열은 heap memory 에 저장하지만, 설명에선 편의를 위해 항상 heap 에 저장한다고 가정한다.)</em></p><p>위 코드에서 B = A 수행 시 copy 가 일어난다. (copy assignment operator)<br>C = std::move(A) 수행 시 move 가 일어난다. (move assignment operator)</p><p>B = A 를 할 때는 copy 하기 때문에 B.data 는 당연히 “aaa” 가 복사되고 A.data 도 여전히 “aaa”를 가지고 있지만<br>C = std::move(A) 를 하면 move 하기 때문에 A.data 는 C.data 로 이동이 되어서 A.data 는 빈 문자열이 되고 C.data 는 “aaa” 를 가진다. 얻을 수 있는 이점은, 새로 메모리를 <code>할당(malloc)</code>하지 않아도 되고 이미 메모리에 할당된 것을 소유권만 C 에게 넘겨주기 때문에 copy 동작보다 빠르다. (move 로 할당한 이후로는 A를 사용하지 못하므로 주의)</p><p>예제를 하나 더 보자.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringList;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> input = <span class="string">"example"</span>;</span><br><span class="line">  stringList.push_back(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::string 을 원소로 가지는 vector stringList 가 선언되어 있고, input 을 push_back 해준다.<br>push_back 이 후에 input은 다시 쓰이지 않기 때문에 위 코드에서 input 은 vector에 string 을 넣기위해서만 만들어진 임시객체의 역할 밖에 되지 않는다. 이럴 때 std::move 를 사용하면 성능 향상이 될 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringList;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> input = <span class="string">"example"</span>;</span><br><span class="line">  stringList.push_back(<span class="built_in">std</span>::move(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 예제에선 std::string 이 move constructor / move assignment operator 를 지원하기 때문에 move로 기대하는 동작을 얻을 수 있는 것이고, 사용자가 정의한 class 의 경우 destructors 나 assignment operators 를 명시적으로 선언했다면 move constructor 나 move assignment operators 가 암시적으로 생성되지 않으므로 직접 작성해주거나 default 로 선언해줘야 할 것이다.</p><p>암시적으로 생성되는 move constructors 의 형태는 아래와 같다. 기본적으로 클래스 멤버변수를 std::move 해서 Rvalue 로 casting 해 초기화한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  myClass(myClass&amp;&amp; rhs)</span><br><span class="line">  : A(<span class="built_in">std</span>::move(rhs.A))</span><br><span class="line">  , B(<span class="built_in">std</span>::move(rhs.B))</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> A;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/rvalue-and-move/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux mount 및 reboot 후에도 자동으로 mount 시켜주기</title>
      <link>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/</link>
      <guid>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/</guid>
      <pubDate>Sun, 08 Sep 2019 08:41:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;mount-기본-명령어&quot;&gt;&lt;a href=&quot;#mount-기본-명령어&quot; class=&quot;headerlink&quot; title=&quot;mount 기본 명령어&quot;&gt;&lt;/a&gt;mount 기본 명령어&lt;/h2&gt;&lt;p&gt;기본적으로 아래 명령어를 사용하면 된다.&lt;/p&gt;
&lt;fi
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="mount-기본-명령어"><a href="#mount-기본-명령어" class="headerlink" title="mount 기본 명령어"></a>mount 기본 명령어</h2><p>기본적으로 아래 명령어를 사용하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /dev/sda1 저장매체를 /mnt/myMount 로 마운트한다.</span></span><br><span class="line">mount /dev/sda1 /mnt/myMount</span><br></pre></td></tr></table></figure><p>이 때 마운트할 대상의 이름을 모르겠다면 ( 위 예제에서 /dev/sda1 과 같은 )<br>fdisk -l 과 df -h 로 확인하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 디스크 / 파티션 정보 출력</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"><span class="comment"># 현재 linux system 에 mount 된 list 및 용량 출력</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="자동으로-mount-하기"><a href="#자동으로-mount-하기" class="headerlink" title="자동으로 mount 하기"></a>자동으로 mount 하기</h2><p>위 설명대로 mount 하면 시스템을 종료하기 전까지는 mount 가 유지되지만 리붓하면 mount를 다시 해줘야 하는 불편함이 있다.<br>reboot 이후에도 mount 상태를 유지하고 싶으면 <code>/etc/fstab</code> 을 수정하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stock fstab - you probably want to override this with a machine specific one</span></span><br><span class="line"></span><br><span class="line">/dev/root/autodefaults11</span><br><span class="line">proc/procprocdefaults00</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">/dev/sda1/mnt/myMountautodefaults02</span><br></pre></td></tr></table></figure><p>사용자마다 /etc/fstab 내용은 다를 수 있다. 기본으로 입력되어 있는 정보들은 잘 못 건드리면 부팅이 안될 수도 있으니 건드리지 말고, 마지막 줄에 mount 하고자 하는 내용을 입력하면 된다.<br>나는 마지막 줄에 /dev/sda1 을 /mnt/myMount 로 mount 하는 line 을 추가했다.<br>마지막에 숫자 0 2 의 의미는 각각 dump 생성 여부 / fsck 실행 순서를 나타내는데, 잘 모르겠다면 0, 2 로 셋팅하면 문제 없을 것이다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/#disqus_thread</comments>
    </item>
    
    <item>
      <title>plink, pscp 로 SSH, SCP 사용하는 방법 (command-line, 자동화)</title>
      <link>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/</link>
      <guid>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/</guid>
      <pubDate>Sun, 01 Sep 2019 08:24:56 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;plink-pscp-어떻게-쓰면-좋을까&quot;&gt;&lt;a href=&quot;#plink-pscp-어떻게-쓰면-좋을까&quot; class=&quot;headerlink&quot; title=&quot;plink, pscp 어떻게 쓰면 좋을까?&quot;&gt;&lt;/a&gt;plink, pscp 어떻게 쓰면 좋을
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="plink-pscp-어떻게-쓰면-좋을까"><a href="#plink-pscp-어떻게-쓰면-좋을까" class="headerlink" title="plink, pscp 어떻게 쓰면 좋을까?"></a>plink, pscp 어떻게 쓰면 좋을까?</h2><p>회사에서 일을 할 때 <code>SSH</code> 나 <code>SCP</code> 등을 사용할 일이 많은데, 보통 아래와 같은 조합으로 사용했다.<br>SSH : TeraTerm, Putty, PowerShell<br>파일 전송 : FileZilla, WinSCP</p><p>위 프로그램들은 잘 사용하고 있었지만, 업무 상 반복적인 작업 들이 있었고 이를 위해 매번 같은 버튼 누르고, 같은  타이핑 하는 등.. 같은 action 을 반복하는 것이 귀찮았다.<br><em>ex) SSH password / 명령어 입력, 테스트를 위해 binary 교체 및 권한 설정 등..</em></p><p><code>plink</code>, <code>pscp</code> 는 이런 전송 반복적인 작업들을 피하기 위해 command-line 기반으로 어떻게 <code>자동화</code>를 할 수 있을 지 알아보다 발견한 툴이다.<br>이미 Putty 를 쓰고 있다면 Putty 에 포함되어 있는 프로그램이고, 다운로드 받고 싶다면 아래 링크에서 받을 수 있다.</p><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" rel="external nofollow noopener noreferrer" target="_blank">Download link</a><br><img src="image-20190901174340033.png" alt="Putty 전체를 받지 않고 plink, pscp 만 따로 받을 수도 있다."></p><p>그리고, 아래와 같이 사용하면 된다. 사용법도 간단하고 pw 를 지정할 수도 있어서 자동화할 때 좋다.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 192.168.11.10 의 host 로 접속해서 pwd 명령</span></span><br><span class="line">plink.exe -ssh -pw &lt;password&gt; host@<span class="number">192.168</span>.<span class="number">11.10</span> <span class="string">"pwd"</span></span><br><span class="line"><span class="comment"># 192.168.11.10 의 ~/dest 폴더로 example.txt 를 복사</span></span><br><span class="line">pscp.exe -scp -r -pw &lt;password&gt; example.txt host@<span class="number">192.168</span>.<span class="number">11.10</span>:~/dest</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>일론 머스크의 뉴럴링크, 뇌와 컴퓨터의 연결</title>
      <link>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/</link>
      <guid>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/</guid>
      <pubDate>Sun, 25 Aug 2019 13:31:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자&quot;&gt;&lt;a href=&quot;#일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자&quot; class=&quot;headerlink&quot; title=&quot;일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자"><a href="#일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자" class="headerlink" title="일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자"></a>일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자</h2><div class="video-container"><iframe src="//www.youtube.com/embed/bBSaxXEOQcM" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/KezI_Lqnj5Q" frameborder="0" allowfullscreen></iframe></div><p>영상의 내용을 아주 간단하게 요약하자면, <code>뉴럴링크</code>란 뇌의 대뇌피질에 작은 칩을 연결해 뇌의 뉴런들이 전달하는 전자기적 신호를 <code>알고리즘</code>으로 분석해서 사람의 생각, 감각, 운동능력 등에 영향을 줄 수 있는 기술이다.<br>1차적으로 <code>파킨슨병</code> 같은 뇌 질환을 앓고 있는 환자들을 위해 사용될 것이고, 2020년 말에는 일반인들에게도 상용화가 될 것이라고 예상한다고 한다.</p><p>뉴럴링크가 상용화된다면, 이제 더 이상 <code>마우스</code>나 <code>키보드</code>, <code>모니터</code> 와 같은 뇌와 컴퓨터간의 <code>입력 매체</code> 및 <code>출력매체</code>가  필요 없어질 수 있다. 다양한 입력 매체의 도움없이도 훨씬 빠르게, 내가 <code>생각하는 속도</code>로 컴퓨터를 조작하고, 출력 매체가 없이도 얻고자 하는 정보를 뇌에 <code>주입</code> 시킬 수도 있는 것이다. 사람들은 인공지능 컴퓨터의 도움으로 현재보다 훨씬 많은 정보를 빠르고 쉽게 습득할 수 있을 것이다. </p><p>과연 2020년 말에는 생각만으로 상호작용을 하는 고도화된 인공지능 비서를 가질 수 있을까?<br><img src="ironman.jpg" alt="아이언맨도 음성인식으로 프라이데이와 통신하는데.."></p><p>아직은 전혀 실감이 나지 않지만 동물을 통한 실험도 어느정도 진행되었고 유의미한 성과를 이룬 것으로 보인다. 인간에게 적용되었을 때 안전성 / 보안성 문제만 해결된다면, <code>특이점</code>을 불러올 기술이라고 생각된다.<br><code>뉴럴링크</code>는 기존의 지식, 인프라를 무너뜨릴 수도 있을 것이다. 한편으론 내가 수년 간 쌓은 지식, 경험이 이 기술이 개발됨에 따라 남들이 쉽게 따라할 수 있다고 생각하면 당장 의욕이 떨어질 수도 있겠다. 하지만 이런 시대가 올 수 있다고 아직 장담할 수 없는 단계이고, 당장 할 수 있는 것도 없다. 그저 경각심을 가지고 현실을 열심히 살면 <code>뉴럴링크</code> 의 시대에도 내가 할 수 있는 것이 있을 것이라고 믿고, 준비해야 한다고 생각한다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iTerm2 3.3 release 이후 Theme 변경 및 Status Bar 사용하기</title>
      <link>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/</link>
      <guid>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/</guid>
      <pubDate>Wed, 21 Aug 2019 16:36:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;새롭게-추가된-Minimal-Theme&quot;&gt;&lt;a href=&quot;#새롭게-추가된-Minimal-Theme&quot; class=&quot;headerlink&quot; title=&quot;새롭게 추가된 Minimal Theme&quot;&gt;&lt;/a&gt;새롭게 추가된 Minimal Theme&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="새롭게-추가된-Minimal-Theme"><a href="#새롭게-추가된-Minimal-Theme" class="headerlink" title="새롭게 추가된 Minimal Theme"></a>새롭게 추가된 Minimal Theme</h2><p><img src="https://user-images.githubusercontent.com/36141584/63451781-e9911180-c47f-11e9-98f5-32e2281a9f41.png" alt><br>하단의 Try it now 를 클릭하면 자동으로 변경됩니다. 이전 기본 테마보다 훨씬 깔끔하네요. 다시 이전 테마로 돌아가고 싶다면 Preferences - Appearance  에서 변경 할 수 있습니다.</p><h2 id="Status-Bar-표시"><a href="#Status-Bar-표시" class="headerlink" title="Status Bar 표시"></a>Status Bar 표시</h2><p><img src="https://user-images.githubusercontent.com/36141584/63452629-b64f8200-c481-11e9-99b9-800b6be28d8b.png" alt>status bar 는 개인설정이 가능합니다. 배터리, CPU, RAM 사용량, 네트워크 대역폭 등 여러 정보 및 Tool 을 status bar 에 설정할 수 있네요.<img src="https://user-images.githubusercontent.com/36141584/63452391-227db600-c481-11e9-870e-98e5c052694c.png" alt></p><h2 id="개인-설정까지-완료된-모습"><a href="#개인-설정까지-완료된-모습" class="headerlink" title="개인 설정까지 완료된 모습"></a>개인 설정까지 완료된 모습</h2><p><img src="https://user-images.githubusercontent.com/36141584/63452195-a3887d80-c480-11e9-8117-a20b645d7b4a.png" alt></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CMake 에서 상대경로를 절대경로로 바꾸기</title>
      <link>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/</link>
      <guid>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/</guid>
      <pubDate>Wed, 21 Aug 2019 15:57:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;CMake-에서-상대경로를-절대경로로-바꿔보자&quot;&gt;&lt;a href=&quot;#CMake-에서-상대경로를-절대경로로-바꿔보자&quot; class=&quot;headerlink&quot; title=&quot;CMake 에서 상대경로를 절대경로로 바꿔보자&quot;&gt;&lt;/a&gt;CMake 에서 상대
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="CMake-에서-상대경로를-절대경로로-바꿔보자"><a href="#CMake-에서-상대경로를-절대경로로-바꿔보자" class="headerlink" title="CMake 에서 상대경로를 절대경로로 바꿔보자"></a>CMake 에서 상대경로를 절대경로로 바꿔보자</h2><blockquote><p>왜 필요한가?</p></blockquote><p><code>CMake</code> 에서 지원하는 여러 명령들 중에 상대 경로로 입력하면 오류가 출력되는 function 들이 있습니다.<br>이때, 상대 경로를 절대 경로로 변환하기 위해 <code>get_filename_component</code> 을 사용하면 됩니다.</p><p>원형:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE])</span><br></pre></td></tr></table></figure><p>아래는 ../../.. 에 해당하는 상대경로를 절대경로로 변환해서, MY_ABSOLUTE_PATH 라는 변수로 저장 시키는 예제 입니다.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(MY_ABSOLUTE_PATH <span class="string">"../../.."</span> ABSOLUTE)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OpenSSL을 NDK로 빌드하기</title>
      <link>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/</link>
      <guid>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 28 Jul 2019 10:02:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;시작에-앞서&quot;&gt;&lt;a href=&quot;#시작에-앞서&quot; class=&quot;headerlink&quot; title=&quot;시작에 앞서&quot;&gt;&lt;/a&gt;시작에 앞서&lt;/h2&gt;&lt;p&gt;보통 실습 용도나 로컬에서 테스트를 할 경우에는 &lt;code&gt;Precompiled library&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="시작에-앞서"><a href="#시작에-앞서" class="headerlink" title="시작에 앞서"></a>시작에 앞서</h2><p>보통 실습 용도나 로컬에서 테스트를 할 경우에는 <code>Precompiled library</code> 를 사용해도 되지만 상용 프로그램에 포함할 경우 <code>암호화 알고리즘 라이센스</code> 문제가 발생할 수 있습니다.<br>문제가 되는 암호화 알고리즘을 제외한 <code>Precompiled library</code> 가 있으면 해결되지만, 특정 <code>NDK</code>, <code>OpenSSL</code> 버전을 맞춰야 하는 경우 이에 만족하는 라이브러리를 찾기가 힘들어서, 직접 빌드하는 편이 빠릅니다.</p><h2 id="빌드-환경-및-사용-버전"><a href="#빌드-환경-및-사용-버전" class="headerlink" title="빌드 환경 및 사용 버전"></a>빌드 환경 및 사용 버전</h2><ol><li>NDK r18b</li><li>OpenSSL 1.0.2l</li><li>Ubuntu 18.04</li></ol><h2 id="빌드-시작하기"><a href="#빌드-시작하기" class="headerlink" title="빌드 시작하기"></a>빌드 시작하기</h2><ol><li><p>NDK 이용해 <code>custom toolchain</code> 생성</p><p>(<a href="https://developer.android.com/ndk/guides/standalone_toolchain" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/ndk/guides/standalone_toolchain</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 <span class="variable">$NDK</span>/build/tools/make_standalone_toolchain.py --arch arm64 --api 26 --install-dir /opt/android-26-arm64</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 폴더로 이동</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openssl-1.0.2l</span><br></pre></td></tr></table></figure></li><li><p>Clang 에서 <code>&#39;-mandroid&#39;</code> 를 지원하지 않으므로 Configure 파일에서 해당 부분 삭제</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">'s/-mandroid//'</span> Configure</span><br></pre></td></tr></table></figure></li><li><p><code>Confiigure</code> 시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE=/opt/android-26-arm64/bin/aarch64-linux-android- ./Configure android shared no-idea no-mdc2 no-rc5</span><br></pre></td></tr></table></figure></li><li><p><code>make</code> 시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make depend</span><br><span class="line">make ANDROID_DEV=/opt/android-26-arm64/sysroot/usr CALC_VERSIONS=<span class="string">"SHLIB_COMPAT=; SHLIB_SOVER="</span> build_libs</span><br></pre></td></tr></table></figure></li><li><p>생성된 library 가 올바르게 빌드 됐는지 확인</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h ./libcrypto.a | grep -i <span class="string">'class\|machine'</span> | head -2</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo 블로그 폰트 사이즈 수정하기 - (Hueman 테마)</title>
      <link>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/</link>
      <guid>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/</guid>
      <pubDate>Sun, 28 Jul 2019 09:17:21 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme&quot;&gt;&lt;a href=&quot;#블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme&quot; class=&quot;headerlink&quot; title=&quot;블로그 게시글의 폰트 사이즈 수정하기 - (Hu
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme"><a href="#블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme" class="headerlink" title="블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)"></a>블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)</h3><p>앞서 <a href="https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/">Hexo-blog-셋팅-정리</a> 에서 소개한 블로그들에서 소개되지 않은 부분이 있는데, 바로 게시글의 폰트 사이즈를 수정하는 방법입니다.<br>기본 사이즈는 18px 로 설정되어 있는데, 미묘하게 큰 사이즈여서 포스트가 한 눈에 들어오지 않는 것 같아 사이즈를 수정했습니다.</p><p>수정하기 위해서 <code>/$HEXO_HOME/themes/hueman/source/css/_variables.styl</code> 파일을 엽니다.<br>그리고, <code>font-size-article</code> 을 찾아서 원하는 사이즈로 수정합니다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//font-size-article = 18px</span></span><br><span class="line"><span class="attribute">font-size</span>-article = <span class="number">17px</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo 블로그 셋팅 총정리</title>
      <link>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/</link>
      <guid>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/</guid>
      <pubDate>Sat, 27 Jul 2019 12:30:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Hexo-블로그-만들기&quot;&gt;&lt;a href=&quot;#Hexo-블로그-만들기&quot; class=&quot;headerlink&quot; title=&quot;Hexo 블로그 만들기&quot;&gt;&lt;/a&gt;Hexo 블로그 만들기&lt;/h2&gt;&lt;p&gt;hexo 블로그를 만들기 위해 참고했던 사이트를 정리해
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Hexo-블로그-만들기"><a href="#Hexo-블로그-만들기" class="headerlink" title="Hexo 블로그 만들기"></a>Hexo 블로그 만들기</h2><p>hexo 블로그를 만들기 위해 참고했던 사이트를 정리해보려 합니다.<br>아래에 있는 블로그만 참조해도 꽤 괜찮은 블로그를 만들 수 있습니다.<br>그 중에서도 <code>Eric Han</code> 님의 블로그의 글이 포스팅 된 지 가장 오래된 글임에도 많은 도움이 됐습니다.</p><h4 id="튜토리얼-with-Hueman-테마"><a href="#튜토리얼-with-Hueman-테마" class="headerlink" title="튜토리얼 with Hueman 테마"></a>튜토리얼 with Hueman 테마</h4><p><a href="https://futurecreator.github.io/categories/Hexo/" rel="external nofollow noopener noreferrer" target="_blank">Eric Han’s IT Blog Powered by Hexo</a><br><a href="https://d2fault.github.io/categories/Blog/Hexo/" rel="external nofollow noopener noreferrer" target="_blank">d2fault</a></p><h4 id="튜토리얼-with-Tranquilpeak-테마"><a href="#튜토리얼-with-Tranquilpeak-테마" class="headerlink" title="튜토리얼 with Tranquilpeak 테마"></a>튜토리얼 with Tranquilpeak 테마</h4><p><a href="https://mingpd.github.io/categories/개발/hexo/" rel="external nofollow noopener noreferrer" target="_blank">밍피디</a></p><h4 id="Markdown-문법"><a href="#Markdown-문법" class="headerlink" title="Markdown 문법"></a>Markdown 문법</h4><p><a href="https://heropy.blog/2017/09/30/markdown/" rel="external nofollow noopener noreferrer" target="_blank">MarkDown 사용법 총정리</a></p><hr><p>190904 Update</p><h4 id="Category-나-Tag-클릭-시-404-error-해결법"><a href="#Category-나-Tag-클릭-시-404-error-해결법" class="headerlink" title="Category 나 Tag 클릭 시 404 error 해결법"></a>Category 나 Tag 클릭 시 404 error 해결법</h4><p>처음 글 썼을 때 생성한 Category 나 Tag 에서 소문자/대문자를 바꿨을 때 이를 인식하지 못 해서 발생하는 문제. 링크에 대해선 대-소문자 구분 없이 통일하는 것이 좋음.<br><a href="https://postlude.github.io/2019/01/21/hexo-category-not-found/" rel="external nofollow noopener noreferrer" target="_blank">Hexo 블로그에서 카테고리(태그)가 제대로 보이지 않을 때</a></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
