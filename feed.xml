<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhwanp&#39;s devNote</title>
    <link>https://yhwanp.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>yhwanp&#39;s devNote</description>
    <pubDate>Sun, 15 Sep 2019 13:21:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>lsof - open 된 파일에 대한 정보 출력</title>
      <link>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/</link>
      <guid>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/</guid>
      <pubDate>Sun, 15 Sep 2019 13:00:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;lsof-란&quot;&gt;&lt;a href=&quot;#lsof-란&quot; class=&quot;headerlink&quot; title=&quot;lsof 란 ?&quot;&gt;&lt;/a&gt;lsof 란 ?&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 는 &lt;code&gt;List Open Files&lt;/code&gt; 의
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="lsof-란"><a href="#lsof-란" class="headerlink" title="lsof 란 ?"></a>lsof 란 ?</h2><p><code>lsof</code> 는 <code>List Open Files</code> 의 약자이고, 시스템에서 열린 파일 목록을 보여준다.<br>여러가지 옵션이 많지만 주로 아래 명령어들만 사용했다.</p><p>특히 특정 프로세스가 file 을 열고 닫지 않아서 발생하는 error 및 crash 를 잡을 때 <code>lsof - p</code>  를 이용하면 어떤 파일을 닫지 않아 <code>fd leak</code> 이 발생하는지 알 수 있어서 코드 상 수정해야할 부분을 캐치하기 쉽다.<br>또 소켓 프로그래밍을 하는 경우엔 포트 점유 목록을 출력하는 명령어가 도움이 될 수 있겠다.</p><p>A. 열린 파일 목록 모두 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>B. 특정 프로세스의 열린 파일 목록 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 다음에 pid 를 입력하면 된다</span></span><br><span class="line">lsof -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>C. TCP 포트 점유 목록 출력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 아래는 22번 TCP 포트를 점유하는 pid 및 fd 를 출력한다</span></span><br><span class="line">lsof -i TCP:22</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/15/how-to-use-lsof/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ std::vector push_back 보단 emplace_back 을 사용하자</title>
      <link>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/</link>
      <guid>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/</guid>
      <pubDate>Sun, 08 Sep 2019 16:58:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;emplace-back-을-사용하자&quot;&gt;&lt;a href=&quot;#emplace-back-을-사용하자&quot; class=&quot;headerlink&quot; title=&quot;emplace_back 을 사용하자&quot;&gt;&lt;/a&gt;emplace_back 을 사용하자&lt;/h2&gt;&lt;p&gt;&lt;c
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="emplace-back-을-사용하자"><a href="#emplace-back-을-사용하자" class="headerlink" title="emplace_back 을 사용하자"></a>emplace_back 을 사용하자</h2><p><code>emplace_back</code> 은 c++11 에 추가된 std::vector 의 멤버함수다.<br>보통 vector 에 값을 넣을 때, 아래와 같이 <code>push_back</code> 을 사용할 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strList;</span><br><span class="line"><span class="comment">// 이렇게 객체를 하나 선언해서 넣거나</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> A = <span class="string">"test"</span>;</span><br><span class="line">strList.push_back(A); </span><br><span class="line"><span class="comment">// 임시 객체를 바로 전달하는 방식</span></span><br><span class="line">strList.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure><p>위와 같이 작성하는 것이 일반적이지만 성능 측면에서 봤을 때 <code>emplace_back</code> 을 사용하는 것이 훨씬 효과적이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strList;</span><br><span class="line">strList.emplace_back(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pair 나 생성자가 있는 다른 모든 class 도 가능</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pairList;</span><br><span class="line">pairList.emplace_back(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><code>push_back</code> 을 사용할 때는 vector 에 값을 넣기 위해 바깥에서 임시 객체의 생성자 / 소멸자가 호출되고 vector 내부에 복사되는 과정에서 또 객체가 한번 더 생성이 되지만,<br><code>emplace_back</code> 을 사용하면, 생성자의 인자 value 들만 전달해주면 vector 내부에서 한번만 객체 생성을 한다.</p><p>거의 대부분의 경우에서 <code>emplace_back</code> 을 사용하는 경우의 속도가 더 빠르고 <code>push_back</code> 을 완벽히 대체할 수 있어서 <code>emplace_back</code> 사용을 권장한다고 한다. 프로젝트에서 C++11 이상을 사용한다면 <code>emplace_back</code> 사용을 고려해보자.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/09/c-vector-emplace-back/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ubuntu SSH Welcome message 추가하기</title>
      <link>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/</link>
      <guid>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/</guid>
      <pubDate>Sun, 08 Sep 2019 10:59:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;client 가 SSH 에 접속할 때마다 출력되는 &lt;code&gt;Welcome message&lt;/code&gt; 를 추가하는 방법이다.&lt;br&gt;&lt;em&gt;(Ubuntu 18.04 기준)&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t
        
      
      </description>
      
      <content:encoded><![CDATA[<p>client 가 SSH 에 접속할 때마다 출력되는 <code>Welcome message</code> 를 추가하는 방법이다.<br><em>(Ubuntu 18.04 기준)</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/update-motd.d 에 99-custom 을 생성해줌.</span></span><br><span class="line">vi /etc/update-motd.d/99-custom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 내용 예제</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"### 내용 입력 ###"</span></span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>who 는 현재 SSH connect 되어있는 client 목록을 보여준다.<br>출력하고 싶은 내용을 자유롭게 입력하면 된다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/ubuntu-ssh-welcome-message/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Rvalue 와 std::move 에 대한 이해</title>
      <link>https://yhwanp.github.io/2019/09/08/rvalue-and-move/</link>
      <guid>https://yhwanp.github.io/2019/09/08/rvalue-and-move/</guid>
      <pubDate>Sun, 08 Sep 2019 09:23:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Rvalue-란-무엇인가&quot;&gt;&lt;a href=&quot;#Rvalue-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;Rvalue 란 무엇인가?&quot;&gt;&lt;/a&gt;Rvalue 란 무엇인가?&lt;/h2&gt;&lt;p&gt;Rvalue, 우측값은 대입 시에 항상 오른
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Rvalue-란-무엇인가"><a href="#Rvalue-란-무엇인가" class="headerlink" title="Rvalue 란 무엇인가?"></a>Rvalue 란 무엇인가?</h2><p>Rvalue, 우측값은 대입 시에 항상 오른쪽에만 오는 식을 말한다.<br>예제로 이해하는 것이 쉽다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;<span class="comment">// x 는 Lvalue, 10은 Rvalue</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">20</span>;<span class="comment">// y 는 Lvalue, 20은 Rvalue</span></span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// x 와 y 모두 Lvalue</span></span><br><span class="line">x = (x + y);<span class="comment">// x 는 Lvalue, x + y 는 Rvalue</span></span><br><span class="line"></span><br><span class="line">x + y = <span class="number">30</span>;<span class="comment">// 잘 못된 코드, Rvalue 인 x + y 에 대입하고 있다.</span></span><br><span class="line"></span><br><span class="line">x = doSomething()<span class="comment">// doSomething() 은 Rvalue</span></span><br></pre></td></tr></table></figure><p>x, y 처럼 이름을 가지고 있고, 그 이름으로 접근할 수 있는 것이 Lvalue 이다.<br>그와 반대로 (x + y) 나 상수 10, 20 등은 이름을 가지고 있지 않고 식이 끝난 후 다음 라인에서 그 값에 접근할 수 없다.</p><p>Rvalue 를 함수의 매개변수로 받고 싶으면 A&amp;&amp; 로 선언한다.<br>참고로 doSomethingWithRvalue 안에서 rhs 를 다시 사용할 때는 rhs 가 Lvalue 라는 것을 주의하자. Rvalue 로 사용하고 싶으면 다시 std::move(rhs) 와 같이 사용해주어야 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="comment">// class A의 instance를 Rvalue 로 받고 싶을 때</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomethingWithRvalue</span><span class="params">(A&amp;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-move-를-사용해서-성능을-개선해보자"><a href="#std-move-를-사용해서-성능을-개선해보자" class="headerlink" title="std::move 를 사용해서 성능을 개선해보자"></a>std::move 를 사용해서 성능을 개선해보자</h2><p><code>std::move</code> 는 이름 때문에 부르는 것과 동시에 어떤 이동 작업이 이뤄질 것 같지만, 실제로 Lvalue 를 Rvalue 로 casting 해줄 뿐이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  myClass()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  myClass(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span><br><span class="line">  : data(str)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">myClass <span class="title">A</span><span class="params">(<span class="string">"aaa"</span>)</span></span>;</span><br><span class="line">myClass B;</span><br><span class="line">myClass C;</span><br><span class="line"></span><br><span class="line">B = A;</span><br><span class="line">C = <span class="built_in">std</span>::move(A);<span class="comment">// Lvalue 인 A를 Rvalue 로 casting</span></span><br></pre></td></tr></table></figure><p><em>(std::string 은 실제 작은 문자열은 stack memory 에 저장하고 큰 문자열은 heap memory 에 저장하지만, 설명에선 편의를 위해 항상 heap 에 저장한다고 가정한다.)</em></p><p>위 코드에서 B = A 수행 시 copy 가 일어난다. (copy assignment operator)<br>C = std::move(A) 수행 시 move 가 일어난다. (move assignment operator)</p><p>B = A 를 할 때는 copy 하기 때문에 B.data 는 당연히 “aaa” 가 복사되고 A.data 도 여전히 “aaa”를 가지고 있지만<br>C = std::move(A) 를 하면 move 하기 때문에 A.data 는 C.data 로 이동이 되어서 A.data 는 빈 문자열이 되고 C.data 는 “aaa” 를 가진다. 얻을 수 있는 이점은, 새로 메모리를 <code>할당(malloc)</code>하지 않아도 되고 이미 메모리에 할당된 것을 소유권만 C 에게 넘겨주기 때문에 copy 동작보다 빠르다. (move 로 할당한 이후로는 A를 사용하지 못하므로 주의)</p><p>예제를 하나 더 보자.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringList;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> input = <span class="string">"example"</span>;</span><br><span class="line">  stringList.push_back(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::string 을 원소로 가지는 vector stringList 가 선언되어 있고, input 을 push_back 해준다.<br>push_back 이 후에 input은 다시 쓰이지 않기 때문에 위 코드에서 input 은 vector에 string 을 넣기위해서만 만들어진 임시객체의 역할 밖에 되지 않는다. 이럴 때 std::move 를 사용하면 성능 향상이 될 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringList;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> input = <span class="string">"example"</span>;</span><br><span class="line">  stringList.push_back(<span class="built_in">std</span>::move(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 예제에선 std::string 이 move constructor / move assignment operator 를 지원하기 때문에 move로 기대하는 동작을 얻을 수 있는 것이고, 사용자가 정의한 class 의 경우 destructors 나 assignment operators 를 명시적으로 선언했다면 move constructor 나 move assignment operators 가 암시적으로 생성되지 않으므로 직접 작성해주거나 default 로 선언해줘야 할 것이다.</p><p>암시적으로 생성되는 move constructors 의 형태는 아래와 같다. 기본적으로 클래스 멤버변수를 std::move 해서 Rvalue 로 casting 해 초기화한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  myClass(myClass&amp;&amp; rhs)</span><br><span class="line">  : A(<span class="built_in">std</span>::move(rhs.A))</span><br><span class="line">  , B(<span class="built_in">std</span>::move(rhs.B))</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> A;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/rvalue-and-move/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux mount 및 reboot 후에도 자동으로 mount 시켜주기</title>
      <link>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/</link>
      <guid>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/</guid>
      <pubDate>Sun, 08 Sep 2019 08:41:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;mount-기본-명령어&quot;&gt;&lt;a href=&quot;#mount-기본-명령어&quot; class=&quot;headerlink&quot; title=&quot;mount 기본 명령어&quot;&gt;&lt;/a&gt;mount 기본 명령어&lt;/h2&gt;&lt;p&gt;기본적으로 아래 명령어를 사용하면 된다.&lt;/p&gt;
&lt;fi
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="mount-기본-명령어"><a href="#mount-기본-명령어" class="headerlink" title="mount 기본 명령어"></a>mount 기본 명령어</h2><p>기본적으로 아래 명령어를 사용하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /dev/sda1 저장매체를 /mnt/myMount 로 마운트한다.</span></span><br><span class="line">mount /dev/sda1 /mnt/myMount</span><br></pre></td></tr></table></figure><p>이 때 마운트할 대상의 이름을 모르겠다면 ( 위 예제에서 /dev/sda1 과 같은 )<br>fdisk -l 과 df -h 로 확인하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 디스크 / 파티션 정보 출력</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"><span class="comment"># 현재 linux system 에 mount 된 list 및 용량 출력</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="자동으로-mount-하기"><a href="#자동으로-mount-하기" class="headerlink" title="자동으로 mount 하기"></a>자동으로 mount 하기</h2><p>위 설명대로 mount 하면 시스템을 종료하기 전까지는 mount 가 유지되지만 리붓하면 mount를 다시 해줘야 하는 불편함이 있다.<br>reboot 이후에도 mount 상태를 유지하고 싶으면 <code>/etc/fstab</code> 을 수정하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stock fstab - you probably want to override this with a machine specific one</span></span><br><span class="line"></span><br><span class="line">/dev/root/autodefaults11</span><br><span class="line">proc/procprocdefaults00</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">/dev/sda1/mnt/myMountautodefaults02</span><br></pre></td></tr></table></figure><p>사용자마다 /etc/fstab 내용은 다를 수 있다. 기본으로 입력되어 있는 정보들은 잘 못 건드리면 부팅이 안될 수도 있으니 건드리지 말고, 마지막 줄에 mount 하고자 하는 내용을 입력하면 된다.<br>나는 마지막 줄에 /dev/sda1 을 /mnt/myMount 로 mount 하는 line 을 추가했다.<br>마지막에 숫자 0 2 의 의미는 각각 dump 생성 여부 / fsck 실행 순서를 나타내는데, 잘 모르겠다면 0, 2 로 셋팅하면 문제 없을 것이다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/08/linux-mount-and-auto-mount/#disqus_thread</comments>
    </item>
    
    <item>
      <title>plink, pscp 로 SSH, SCP 사용하는 방법 (command-line, 자동화)</title>
      <link>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/</link>
      <guid>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/</guid>
      <pubDate>Sun, 01 Sep 2019 08:24:56 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;plink-pscp-어떻게-쓰면-좋을까&quot;&gt;&lt;a href=&quot;#plink-pscp-어떻게-쓰면-좋을까&quot; class=&quot;headerlink&quot; title=&quot;plink, pscp 어떻게 쓰면 좋을까?&quot;&gt;&lt;/a&gt;plink, pscp 어떻게 쓰면 좋을
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="plink-pscp-어떻게-쓰면-좋을까"><a href="#plink-pscp-어떻게-쓰면-좋을까" class="headerlink" title="plink, pscp 어떻게 쓰면 좋을까?"></a>plink, pscp 어떻게 쓰면 좋을까?</h2><p>회사에서 일을 할 때 <code>SSH</code> 나 <code>SCP</code> 등을 사용할 일이 많은데, 보통 아래와 같은 조합으로 사용했다.<br>SSH : TeraTerm, Putty, PowerShell<br>파일 전송 : FileZilla, WinSCP</p><p>위 프로그램들은 잘 사용하고 있었지만, 업무 상 반복적인 작업 들이 있었고 이를 위해 매번 같은 버튼 누르고, 같은  타이핑 하는 등.. 같은 action 을 반복하는 것이 귀찮았다.<br><em>ex) SSH password / 명령어 입력, 테스트를 위해 binary 교체 및 권한 설정 등..</em></p><p><code>plink</code>, <code>pscp</code> 는 이런 전송 반복적인 작업들을 피하기 위해 command-line 기반으로 어떻게 <code>자동화</code>를 할 수 있을 지 알아보다 발견한 툴이다.<br>이미 Putty 를 쓰고 있다면 Putty 에 포함되어 있는 프로그램이고, 다운로드 받고 싶다면 아래 링크에서 받을 수 있다.</p><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" rel="external nofollow noopener noreferrer" target="_blank">Download link</a><br><img src="image-20190901174340033.png" alt="Putty 전체를 받지 않고 plink, pscp 만 따로 받을 수도 있다."></p><p>그리고, 아래와 같이 사용하면 된다. 사용법도 간단하고 pw 를 지정할 수도 있어서 자동화할 때 좋다.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 192.168.11.10 의 host 로 접속해서 pwd 명령</span></span><br><span class="line">plink.exe -ssh -pw &lt;password&gt; host@<span class="number">192.168</span>.<span class="number">11.10</span> <span class="string">"pwd"</span></span><br><span class="line"><span class="comment"># 192.168.11.10 의 ~/dest 폴더로 example.txt 를 복사</span></span><br><span class="line">pscp.exe -scp -r -pw &lt;password&gt; example.txt host@<span class="number">192.168</span>.<span class="number">11.10</span>:~/dest</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/09/01/how-to-ssh-scp-with-command-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>일론 머스크의 뉴럴링크, 뇌와 컴퓨터의 연결</title>
      <link>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/</link>
      <guid>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/</guid>
      <pubDate>Sun, 25 Aug 2019 13:31:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자&quot;&gt;&lt;a href=&quot;#일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자&quot; class=&quot;headerlink&quot; title=&quot;일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자"><a href="#일론-머스크의-뉴럴링크에-대해-잘-설명된-유튜브-영상을-보자" class="headerlink" title="일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자"></a>일론 머스크의 뉴럴링크에 대해 잘 설명된 유튜브 영상을 보자</h2><div class="video-container"><iframe src="//www.youtube.com/embed/bBSaxXEOQcM" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/KezI_Lqnj5Q" frameborder="0" allowfullscreen></iframe></div><p>영상의 내용을 아주 간단하게 요약하자면, <code>뉴럴링크</code>란 뇌의 대뇌피질에 작은 칩을 연결해 뇌의 뉴런들이 전달하는 전자기적 신호를 <code>알고리즘</code>으로 분석해서 사람의 생각, 감각, 운동능력 등에 영향을 줄 수 있는 기술이다.<br>1차적으로 <code>파킨슨병</code> 같은 뇌 질환을 앓고 있는 환자들을 위해 사용될 것이고, 2020년 말에는 일반인들에게도 상용화가 될 것이라고 예상한다고 한다.</p><p>뉴럴링크가 상용화된다면, 이제 더 이상 <code>마우스</code>나 <code>키보드</code>, <code>모니터</code> 와 같은 뇌와 컴퓨터간의 <code>입력 매체</code> 및 <code>출력매체</code>가  필요 없어질 수 있다. 다양한 입력 매체의 도움없이도 훨씬 빠르게, 내가 <code>생각하는 속도</code>로 컴퓨터를 조작하고, 출력 매체가 없이도 얻고자 하는 정보를 뇌에 <code>주입</code> 시킬 수도 있는 것이다. 사람들은 인공지능 컴퓨터의 도움으로 현재보다 훨씬 많은 정보를 빠르고 쉽게 습득할 수 있을 것이다. </p><p>과연 2020년 말에는 생각만으로 상호작용을 하는 고도화된 인공지능 비서를 가질 수 있을까?<br><img src="ironman.jpg" alt="아이언맨도 음성인식으로 프라이데이와 통신하는데.."></p><p>아직은 전혀 실감이 나지 않지만 동물을 통한 실험도 어느정도 진행되었고 유의미한 성과를 이룬 것으로 보인다. 인간에게 적용되었을 때 안전성 / 보안성 문제만 해결된다면, <code>특이점</code>을 불러올 기술이라고 생각된다.<br><code>뉴럴링크</code>는 기존의 지식, 인프라를 무너뜨릴 수도 있을 것이다. 한편으론 내가 수년 간 쌓은 지식, 경험이 이 기술이 개발됨에 따라 남들이 쉽게 따라할 수 있다고 생각하면 당장 의욕이 떨어질 수도 있겠다. 하지만 이런 시대가 올 수 있다고 아직 장담할 수 없는 단계이고, 당장 할 수 있는 것도 없다. 그저 경각심을 가지고 현실을 열심히 살면 <code>뉴럴링크</code> 의 시대에도 내가 할 수 있는 것이 있을 것이라고 믿고, 준비해야 한다고 생각한다.</p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/25/elon-musk-neuralink/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iTerm2 3.3 release 이후 Theme 변경 및 Status Bar 사용하기</title>
      <link>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/</link>
      <guid>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/</guid>
      <pubDate>Wed, 21 Aug 2019 16:36:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;새롭게-추가된-Minimal-Theme&quot;&gt;&lt;a href=&quot;#새롭게-추가된-Minimal-Theme&quot; class=&quot;headerlink&quot; title=&quot;새롭게 추가된 Minimal Theme&quot;&gt;&lt;/a&gt;새롭게 추가된 Minimal Theme&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="새롭게-추가된-Minimal-Theme"><a href="#새롭게-추가된-Minimal-Theme" class="headerlink" title="새롭게 추가된 Minimal Theme"></a>새롭게 추가된 Minimal Theme</h2><p><img src="https://user-images.githubusercontent.com/36141584/63451781-e9911180-c47f-11e9-98f5-32e2281a9f41.png" alt><br>하단의 Try it now 를 클릭하면 자동으로 변경됩니다. 이전 기본 테마보다 훨씬 깔끔하네요. 다시 이전 테마로 돌아가고 싶다면 Preferences - Appearance  에서 변경 할 수 있습니다.</p><h2 id="Status-Bar-표시"><a href="#Status-Bar-표시" class="headerlink" title="Status Bar 표시"></a>Status Bar 표시</h2><p><img src="https://user-images.githubusercontent.com/36141584/63452629-b64f8200-c481-11e9-99b9-800b6be28d8b.png" alt>status bar 는 개인설정이 가능합니다. 배터리, CPU, RAM 사용량, 네트워크 대역폭 등 여러 정보 및 Tool 을 status bar 에 설정할 수 있네요.<img src="https://user-images.githubusercontent.com/36141584/63452391-227db600-c481-11e9-870e-98e5c052694c.png" alt></p><h2 id="개인-설정까지-완료된-모습"><a href="#개인-설정까지-완료된-모습" class="headerlink" title="개인 설정까지 완료된 모습"></a>개인 설정까지 완료된 모습</h2><p><img src="https://user-images.githubusercontent.com/36141584/63452195-a3887d80-c480-11e9-8117-a20b645d7b4a.png" alt></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/22/iterm2-3-3-update/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CMake 에서 상대경로를 절대경로로 바꾸기</title>
      <link>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/</link>
      <guid>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/</guid>
      <pubDate>Wed, 21 Aug 2019 15:57:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;CMake-에서-상대경로를-절대경로로-바꿔보자&quot;&gt;&lt;a href=&quot;#CMake-에서-상대경로를-절대경로로-바꿔보자&quot; class=&quot;headerlink&quot; title=&quot;CMake 에서 상대경로를 절대경로로 바꿔보자&quot;&gt;&lt;/a&gt;CMake 에서 상대
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="CMake-에서-상대경로를-절대경로로-바꿔보자"><a href="#CMake-에서-상대경로를-절대경로로-바꿔보자" class="headerlink" title="CMake 에서 상대경로를 절대경로로 바꿔보자"></a>CMake 에서 상대경로를 절대경로로 바꿔보자</h2><blockquote><p>왜 필요한가?</p></blockquote><p><code>CMake</code> 에서 지원하는 여러 명령들 중에 상대 경로로 입력하면 오류가 출력되는 function 들이 있습니다.<br>이때, 상대 경로를 절대 경로로 변환하기 위해 <code>get_filename_component</code> 을 사용하면 됩니다.</p><p>원형:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE])</span><br></pre></td></tr></table></figure><p>아래는 ../../.. 에 해당하는 상대경로를 절대경로로 변환해서, MY_ABSOLUTE_PATH 라는 변수로 저장 시키는 예제 입니다.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(MY_ABSOLUTE_PATH <span class="string">"../../.."</span> ABSOLUTE)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/08/22/cmake-convert-to-absolute-path/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OpenSSL을 NDK로 빌드하기</title>
      <link>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/</link>
      <guid>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 28 Jul 2019 10:02:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;시작에-앞서&quot;&gt;&lt;a href=&quot;#시작에-앞서&quot; class=&quot;headerlink&quot; title=&quot;시작에 앞서&quot;&gt;&lt;/a&gt;시작에 앞서&lt;/h2&gt;&lt;p&gt;보통 실습 용도나 로컬에서 테스트를 할 경우에는 &lt;code&gt;Precompiled library&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="시작에-앞서"><a href="#시작에-앞서" class="headerlink" title="시작에 앞서"></a>시작에 앞서</h2><p>보통 실습 용도나 로컬에서 테스트를 할 경우에는 <code>Precompiled library</code> 를 사용해도 되지만 상용 프로그램에 포함할 경우 <code>암호화 알고리즘 라이센스</code> 문제가 발생할 수 있습니다.<br>문제가 되는 암호화 알고리즘을 제외한 <code>Precompiled library</code> 가 있으면 해결되지만, 특정 <code>NDK</code>, <code>OpenSSL</code> 버전을 맞춰야 하는 경우 이에 만족하는 라이브러리를 찾기가 힘들어서, 직접 빌드하는 편이 빠릅니다.</p><h2 id="빌드-환경-및-사용-버전"><a href="#빌드-환경-및-사용-버전" class="headerlink" title="빌드 환경 및 사용 버전"></a>빌드 환경 및 사용 버전</h2><ol><li>NDK r18b</li><li>OpenSSL 1.0.2l</li><li>Ubuntu 18.04</li></ol><h2 id="빌드-시작하기"><a href="#빌드-시작하기" class="headerlink" title="빌드 시작하기"></a>빌드 시작하기</h2><ol><li><p>NDK 이용해 <code>custom toolchain</code> 생성</p><p>(<a href="https://developer.android.com/ndk/guides/standalone_toolchain" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/ndk/guides/standalone_toolchain</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 <span class="variable">$NDK</span>/build/tools/make_standalone_toolchain.py --arch arm64 --api 26 --install-dir /opt/android-26-arm64</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 폴더로 이동</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openssl-1.0.2l</span><br></pre></td></tr></table></figure></li><li><p>Clang 에서 <code>&#39;-mandroid&#39;</code> 를 지원하지 않으므로 Configure 파일에서 해당 부분 삭제</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">'s/-mandroid//'</span> Configure</span><br></pre></td></tr></table></figure></li><li><p><code>Confiigure</code> 시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE=/opt/android-26-arm64/bin/aarch64-linux-android- ./Configure android shared no-idea no-mdc2 no-rc5</span><br></pre></td></tr></table></figure></li><li><p><code>make</code> 시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make depend</span><br><span class="line">make ANDROID_DEV=/opt/android-26-arm64/sysroot/usr CALC_VERSIONS=<span class="string">"SHLIB_COMPAT=; SHLIB_SOVER="</span> build_libs</span><br></pre></td></tr></table></figure></li><li><p>생성된 library 가 올바르게 빌드 됐는지 확인</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h ./libcrypto.a | grep -i <span class="string">'class\|machine'</span> | head -2</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/28/OpenSSL%EC%9D%84-NDK%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo 블로그 폰트 사이즈 수정하기 - (Hueman 테마)</title>
      <link>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/</link>
      <guid>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/</guid>
      <pubDate>Sun, 28 Jul 2019 09:17:21 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme&quot;&gt;&lt;a href=&quot;#블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme&quot; class=&quot;headerlink&quot; title=&quot;블로그 게시글의 폰트 사이즈 수정하기 - (Hu
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme"><a href="#블로그-게시글의-폰트-사이즈-수정하기-Hueman-Theme" class="headerlink" title="블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)"></a>블로그 게시글의 폰트 사이즈 수정하기 - (Hueman Theme)</h3><p>앞서 <a href="https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/">Hexo-blog-셋팅-정리</a> 에서 소개한 블로그들에서 소개되지 않은 부분이 있는데, 바로 게시글의 폰트 사이즈를 수정하는 방법입니다.<br>기본 사이즈는 18px 로 설정되어 있는데, 미묘하게 큰 사이즈여서 포스트가 한 눈에 들어오지 않는 것 같아 사이즈를 수정했습니다.</p><p>수정하기 위해서 <code>/$HEXO_HOME/themes/hueman/source/css/_variables.styl</code> 파일을 엽니다.<br>그리고, <code>font-size-article</code> 을 찾아서 원하는 사이즈로 수정합니다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//font-size-article = 18px</span></span><br><span class="line"><span class="attribute">font-size</span>-article = <span class="number">17px</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/28/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-Hueman-%ED%85%8C%EB%A7%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo 블로그 셋팅 총정리</title>
      <link>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/</link>
      <guid>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/</guid>
      <pubDate>Sat, 27 Jul 2019 12:30:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Hexo-블로그-만들기&quot;&gt;&lt;a href=&quot;#Hexo-블로그-만들기&quot; class=&quot;headerlink&quot; title=&quot;Hexo 블로그 만들기&quot;&gt;&lt;/a&gt;Hexo 블로그 만들기&lt;/h2&gt;&lt;p&gt;hexo 블로그를 만들기 위해 참고했던 사이트를 정리해
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Hexo-블로그-만들기"><a href="#Hexo-블로그-만들기" class="headerlink" title="Hexo 블로그 만들기"></a>Hexo 블로그 만들기</h2><p>hexo 블로그를 만들기 위해 참고했던 사이트를 정리해보려 합니다.<br>아래에 있는 블로그만 참조해도 꽤 괜찮은 블로그를 만들 수 있습니다.<br>그 중에서도 <code>Eric Han</code> 님의 블로그의 글이 포스팅 된 지 가장 오래된 글임에도 많은 도움이 됐습니다.</p><h4 id="튜토리얼-with-Hueman-테마"><a href="#튜토리얼-with-Hueman-테마" class="headerlink" title="튜토리얼 with Hueman 테마"></a>튜토리얼 with Hueman 테마</h4><p><a href="https://futurecreator.github.io/categories/Hexo/" rel="external nofollow noopener noreferrer" target="_blank">Eric Han’s IT Blog Powered by Hexo</a><br><a href="https://d2fault.github.io/categories/Blog/Hexo/" rel="external nofollow noopener noreferrer" target="_blank">d2fault</a></p><h4 id="튜토리얼-with-Tranquilpeak-테마"><a href="#튜토리얼-with-Tranquilpeak-테마" class="headerlink" title="튜토리얼 with Tranquilpeak 테마"></a>튜토리얼 with Tranquilpeak 테마</h4><p><a href="https://mingpd.github.io/categories/개발/hexo/" rel="external nofollow noopener noreferrer" target="_blank">밍피디</a></p><h4 id="Markdown-문법"><a href="#Markdown-문법" class="headerlink" title="Markdown 문법"></a>Markdown 문법</h4><p><a href="https://heropy.blog/2017/09/30/markdown/" rel="external nofollow noopener noreferrer" target="_blank">MarkDown 사용법 총정리</a></p><hr><p>190904 Update</p><h4 id="Category-나-Tag-클릭-시-404-error-해결법"><a href="#Category-나-Tag-클릭-시-404-error-해결법" class="headerlink" title="Category 나 Tag 클릭 시 404 error 해결법"></a>Category 나 Tag 클릭 시 404 error 해결법</h4><p>처음 글 썼을 때 생성한 Category 나 Tag 에서 소문자/대문자를 바꿨을 때 이를 인식하지 못 해서 발생하는 문제. 링크에 대해선 대-소문자 구분 없이 통일하는 것이 좋음.<br><a href="https://postlude.github.io/2019/01/21/hexo-category-not-found/" rel="external nofollow noopener noreferrer" target="_blank">Hexo 블로그에서 카테고리(태그)가 제대로 보이지 않을 때</a></p>]]></content:encoded>
      
      <comments>https://yhwanp.github.io/2019/07/27/Hexo-blog-setting/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
